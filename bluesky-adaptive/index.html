<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bluesky-adaptive Documentation &mdash; bluesky-adaptive 0.post1+gf21d6ff documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=87a3e413"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            bluesky-adaptive
          </a>
              <div class="version">
                0.post1+gf21d6ff
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.html">Distributed Agents</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_gen/bluesky_adaptive.per_event.recommender_factory.html">bluesky_adaptive.per_event.recommender_factory</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_gen/bluesky_adaptive.per_event.adaptive_plan.html">bluesky_adaptive.per_event.adaptive_plan</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_gen/bluesky_adaptive.per_start.recommender_factory.html">bluesky_adaptive.per_start.recommender_factory</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_gen/bluesky_adaptive.per_start.adaptive_plan.html">bluesky_adaptive.per_start.adaptive_plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_gen/bluesky_adaptive.on_stop.recommender_factory.html">bluesky_adaptive.on_stop.recommender_factory</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">bluesky-adaptive</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">bluesky-adaptive Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bluesky-adaptive-documentation">
<h1>bluesky-adaptive Documentation<a class="headerlink" href="#bluesky-adaptive-documentation" title="Permalink to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed.html">Distributed Agents</a></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is currently under rapid development, the API may change at
any time.</p>
</div>
<section id="adaptive-ness-in-plans">
<h2>Adaptive-ness in plans<a class="headerlink" href="#adaptive-ness-in-plans" title="Permalink to this heading">¶</a></h2>
<p>Fixed plans (ex <code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">scan</span></code>) are
sufficient for many science use-cases, but in some cases having the
plan respond (adapt) to the data as it is being taken can provide
significant improvements to the quality of the data collected while
simultaneously reducing the collection time.  The feedback between the data
and the plan can be at many levels of fidelity:</p>
<ul class="simple">
<li><p>detecting if the data looks “bad” (the sample fell out of the beam)
and stopping acquisition</p></li>
<li><p>detecting when the data is at a sufficient signal to noise</p></li>
<li><p>beamline alignment / tuning / sample centering</p></li>
<li><p>auto-exposure</p></li>
<li><p>selecting points in phase space to measure next</p></li>
<li><p>controlling the speed of a temperature ramp</p></li>
<li><p>selecting what sample to measure next</p></li>
<li><p>driving synthesis and simulation workloads</p></li>
</ul>
<p>This package provides a set of reference tools for implementing in-the-loop
feedback on scientific signals on the seconds-to-minutes time scale in the
context of the <a class="reference external" href="https://blueskyproject.io/">bluesky project</a>.</p>
<section id="dimensions-of-adaptive-ness">
<h3>Dimensions of Adaptive-ness<a class="headerlink" href="#dimensions-of-adaptive-ness" title="Permalink to this heading">¶</a></h3>
<p>Given the breadth of what can be considered “adaptive”, we propose breaking
these down along three axis: the coordination motif, the source of the signal
we are using for the feedback and the timescale of the feedback loop.</p>
<p>The communication between the plan and the recommendation engine can either be
synchronous, “in-the-loop”, or asynchronous.  In the synchronous case we block
progress on the scan while we wait for the next recommendation (based on the
freshest data!).  This is best for cases where the cost of generating the
recommendation is low and the cost of taking the wrong measurement is high.
For example, this motif is very natural when using AI to drive the scanning
of a 2D sample.  However, synchronous communication implies a very tight coupling
between the plan and the recommendation engine which is not always desirable.  We
can achieve looser coupling by using asynchronous communication where the
plan is able to continue running and periodically checks for input from the
recommendation engines.   Examples of this include the suspenders concept
built in the RunEnigne which can be used to pause and resume the experiment if
the beam dumps.  Another example is a temperature ramp where the ramp rate is
dynamically controlled by machine (or human) intervention.</p>
<p>The information that we want to feedback on can be roughly classified into two
categories: engineering values and scientific values.  Engineering values are
things like the current ring current, the flux of x-rays in an ion chamber, or
if the shutters are open.  These are things that the control systems provide
and if they are in bad states will result is useless data, however interpreting
them does not require knowing anything about the sample or science being done.
On the other hand science signal are very tightly coupled to the current
experiment and their interpretation is context dependent.  In the case of
studying a phase change a sudden drop in intensity may indicate that you are
near the transition point or grain boundary and should slow down to collect
more data about this region of phase space.  On the other hand, if you are
trying to map a sample with fluorescence a drop in intensity may indicate you
have scanned off the sample and need to scan back as this part of the phase
space has no scientific value!</p>
<p>The final dimension of adaptive experiments is timescale on which the feedback
needs to happen.  This is controlled by both how long the computations take and
how quickly the system can respond to the feedback.  For example, a PID loop
that maintains the alignment of a mirror is an adaptive experiment, the control
system is changing the hardware based of measurements, but the need to respond
on the sub-ms timescale leaves very little time budget for computation!  On the
other hand, if you want to use experimental results to guide what chemical
synthesis to run, and the synthesis takes a day to complete, you have a
significantly bigger computation budget.  There are natural scales at sub-ms,
best handled in the control system, sub-second for per-step adaptive and
suspender logic, second-to-minute for inter-run, and minutes-to-longer.</p>
<p>Each combination of communication motif, signal class, and timescale has a use
and which ones to pick will depend on the requirements and constraints on a
per-facility, per-beamline, and per-experiment basis.  A given experiment may
even make use of adaptivness from multiple levels!  There is abundant prior art
in this space, being able to feedback measurements to acquisition is not a
novel idea.</p>
</section>
<section id="bluesky-integration-layer">
<h3>Bluesky Integration layer<a class="headerlink" href="#bluesky-integration-layer" title="Permalink to this heading">¶</a></h3>
<p>Adaptive-ness can be inserted into the data collection process at several
levels, primarily driven by the timescale of the feedback.</p>
<ol class="arabic simple">
<li><p>below <code class="docutils literal notranslate"><span class="pre">bluesky</span></code> and in (or below) the control system</p></li>
<li><p>in <code class="docutils literal notranslate"><span class="pre">bluesky</span></code> plans, but without generating <code class="xref py py-obj docutils literal notranslate"><span class="pre">event</span></code></p></li>
<li><p>providing feedback on a per-<code class="xref py py-obj docutils literal notranslate"><span class="pre">event</span></code> basis</p></li>
<li><p>providing feedback on a per-run / <code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code> basis</p></li>
<li><p>providing feedback across many runs</p></li>
</ol>
<section id="in-or-below-the-controls-system">
<h4>In or below the controls system<a class="headerlink" href="#in-or-below-the-controls-system" title="Permalink to this heading">¶</a></h4>
<p>If you need to make decisions on very short time scales (and have a computation
than can fit in the time budget) doing “adaptive” in or below the control
system maybe a good choice.  One example of this is in the scaler devices that
are used as the backend electronics for integrating point detector on many
beamlines.  Typically they are configured to take a fixed length exposure,
however they can be configured to gate on any of the channels.  Thus by gating
on the I0 (incoming photon flux) channel your other wise fixed plan would
“adapt” the exposure time to account for upstream fluctuations in photon
intensity.</p>
<p>You could also imagine a scenario with an imaging detector where we have an
efficient way of telling if the image contains “good” data or not.  If we put
the logic in the image acquisition pipe line we could ask to take “N <em>good</em>
images” and the plan would adapt by taking as many frames as required until the
requested number of good frames were captured.</p>
<p>Configuring adaptiveness at this level can provide huge benefits, it
transparently works for any plan we run, but can be very time consuming to
develop and may be hardware-specific.  In general this level of adaptiveness is
out-of-scope for this package.</p>
</section>
<section id="in-plans-but-below-events">
<h4>In plans, but below Events<a class="headerlink" href="#in-plans-but-below-events" title="Permalink to this heading">¶</a></h4>
<p>At the most granular level <code class="docutils literal notranslate"><span class="pre">bluesky</span></code> gives the plan author access to
the data extracted from the control system before it is processed
through the <a class="reference external" href="https://blueskyproject.io/event_model">event_model</a>
documents.  This is the level that we use in the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptive_scan</span></code> which is bundled with <code class="docutils literal notranslate"><span class="pre">bluesky</span></code>.
This level has also been used at LCLS who implement the frame dropping
logic described above at the plan level (via
<code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code>).</p>
<p>This level gives the author a tremendous amount of flexibility and can
be used to prevent “bad” data from entering the document stream, but quickly
becomes very plan-specific and difficult to generalize and re-use.  This level
is documented else where and out of scope for this project.</p>
</section>
<section id="per-event">
<span id="id1"></span><h4>Per-Event<a class="headerlink" href="#per-event" title="Permalink to this heading">¶</a></h4>
<p>In cases where the computation we need to do to recommend the next step
is fast compared to the time it takes to collect a single data point (
aka an <code class="xref py py-obj docutils literal notranslate"><span class="pre">event</span></code>), then it makes sense to run
the recommendation engine on every Event.  At the end of the plan we will
have 1 run who’s path through phase space was driven by the data.</p>
<p>Examples of this are a 1D scan that samples more finely around the center
of a peak or a 2D scan across gradient sample that samples more finely
at phase boundaries.  In these cases there is a 1:1 mapping between an
event collected and a recommendation for the next point to collect.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="api_gen/bluesky_adaptive.per_event.recommender_factory.html#bluesky_adaptive.per_event.recommender_factory" title="bluesky_adaptive.per_event.recommender_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bluesky_adaptive.per_event.recommender_factory</span></code></a></p></td>
<td><p>Generate the callback and queue for gpCAM integration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api_gen/bluesky_adaptive.per_event.adaptive_plan.html#bluesky_adaptive.per_event.adaptive_plan" title="bluesky_adaptive.per_event.adaptive_plan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bluesky_adaptive.per_event.adaptive_plan</span></code></a></p></td>
<td><p>Execute an adaptive scan using an per event-run recommendation engine.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="per-run">
<h4>Per-Run<a class="headerlink" href="#per-run" title="Permalink to this heading">¶</a></h4>
<p>In cases where the data we need to make a decision about what to do next
maps more closely to a Run, we do the same as the <a class="reference internal" href="#per-event"><span class="std std-ref">Per-Event</span></a> case, but
only expect a recommendation once per-run.</p>
<p>An example of this could be a 2D map where at each point we take a
XANES scan and then focus on points of interest with in the map.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="api_gen/bluesky_adaptive.per_start.recommender_factory.html#bluesky_adaptive.per_start.recommender_factory" title="bluesky_adaptive.per_start.recommender_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bluesky_adaptive.per_start.recommender_factory</span></code></a></p></td>
<td><p>Generate the callback and queue for an Adaptive API backed reccomender.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api_gen/bluesky_adaptive.per_start.adaptive_plan.html#bluesky_adaptive.per_start.adaptive_plan" title="bluesky_adaptive.per_start.adaptive_plan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bluesky_adaptive.per_start.adaptive_plan</span></code></a></p></td>
<td><p>Execute an adaptive scan using an inter-run recommendation engine.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api_gen/bluesky_adaptive.on_stop.recommender_factory.html#bluesky_adaptive.on_stop.recommender_factory" title="bluesky_adaptive.on_stop.recommender_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bluesky_adaptive.on_stop.recommender_factory</span></code></a></p></td>
<td><p>Generate the callback and queue for an Adaptive API backed reccomender.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="per-many-runs">
<h4>Per-many-runs<a class="headerlink" href="#per-many-runs" title="Permalink to this heading">¶</a></h4>
<p>At this scale we need to collect and process the results from many run before
making any recommendations as to the next step.  While this can be thought of
as a variation of the per-run level, this requires additional infrastructure
for reliable plan queuing, as implemented by <a class="reference external" href="https://blueskyproject.io/bluesky-queueserver">queueserver</a>, and is out of scope for this
project.</p>
</section>
</section>
<section id="asynchronous-and-decoupled-feedback">
<h3>Asynchronous and decoupled feedback<a class="headerlink" href="#asynchronous-and-decoupled-feedback" title="Permalink to this heading">¶</a></h3>
<p>In some cases we do want or need a tightly coupled synchronous coordination
between data collection and the computation.  In both the per-event and per-run
levels, the plan is expecting a 1:1 response from the recommendation engine for
each piece of data collected.  In general, the plan has to wait for the
response from algorithm before continuing.</p>
<p>Alternatively, we may instead want have an agent watching the data and
assessing the quality.  If we detect we have collected enough data on the
sample and further exposure would waste beamtime and put excess dose on the
sample we want to complete the plan early.  Conversely, if we detect that the
data is junk (like the sample is no longer in the beam) we want to abort the
plan.  While this watch dog process can save us time, we do not want to slow
down data collection to wait for permission to continue at every point!  In
this case we only need to convey 3 possible states to the RunEngine and plan
<code class="docutils literal notranslate"><span class="pre">{'keep</span> <span class="pre">going',</span> <span class="pre">'you</span> <span class="pre">have</span> <span class="pre">enough</span> <span class="pre">data',</span> <span class="pre">'this</span> <span class="pre">data</span> <span class="pre">is</span> <span class="pre">garbage</span> <span class="pre">please</span> <span class="pre">stop'}</span></code>.
In an analogy to <a class="reference external" href="https://blueskyproject.io/bluesky/state-machine.html#automated-suspension">Suspenders</a>,
this can be done at the RunEnigne level (as has been done at APS) so the plan
does not need to even be aware of the watch dog to benefit from it.</p>
<p>A slightly more coupled example of asynchronous feedback is a 1D scan that
looks at a PV (or other shared state) for what its step size is.  If the step
size is set by a user to a fixed value an the plan run it behaves as a standard
<code class="xref py py-obj docutils literal notranslate"><span class="pre">scan</span></code> with a fixed step size.  However, there could be an agent
(or a human!) watching the data and adjusting the step size based on the how
“interesting” the data currently looks.  By this mechanism we would spend more
time collecting data in “interesting” parts of phase space and extract more
science for a given amount of beamtime.</p>
<p>In both of these cases the feedback is adding value without imposing a cost to
the plans and the failure mode of the computation failing is the current status
quo.</p>
<p>An increasingly desirable operating paradigm for autonomous experiments considers
the directives of many agents, or even networks of agents,
including multiple human agents. The previously described lock-step approaches to
experiment and analysis, leave no room for human experts to engage in the loop,
incorporation of information from complementary techniques, or the integration of
multiple computational agents. In this more complex paradigm, various agents must be
able to process the captured data stream, suggest plans to be executed,
and create reports for human consumption. This is exemplified in the case where
multiple passive agents are performing dataset factorization or AI-based compression
algorithms that provide visualization tools for users,  multiple active learning
agents are providing suggestions for next experiments as they complete their
computation, and human agents are also guiding the experiment
(see this <a class="reference external" href="https://arxiv.org/abs/2301.09177">NeurIPS Workshop Paper</a>).</p>
<p>Here, the same <code class="code docutils literal notranslate"><span class="pre">tell</span></code>, <code class="code docutils literal notranslate"><span class="pre">report</span></code>, <code class="code docutils literal notranslate"><span class="pre">ask</span></code> grammar can be used in conjunction with
Kafka, Tiled, and the RunManager. This adds some additional dependencies including
<code class="docutils literal notranslate"><span class="pre">bluesky-queueserver</span></code>, <code class="docutils literal notranslate"><span class="pre">tiled</span></code>, and <code class="docutils literal notranslate"><span class="pre">bluesky-kafka</span></code>.
Examples of these agents are provided in <a class="reference internal" href="distributed.html#distributed"><span class="std std-ref">Distributed Agents</span></a>.
Furthermore, using Kafka for distributed communication, one can construct meta-agents,
or <em>adjudicators</em>, which coordinate between a collection of agents in more sophisticated ways
than the RunManager priority queue and provide an additional avenue for human intervention.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-right" title="Installation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NSLS-II.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>