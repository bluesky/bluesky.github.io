<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Annotating Bluesky Plans &mdash; bluesky-queueserver 0.post1+g64aa1f6 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="bluesky_queueserver.parameter_annotation_decorator" href="generated/bluesky_queueserver.parameter_annotation_decorator.html" />
    <link rel="prev" title="bluesky_queueserver.validate_plan" href="generated/bluesky_queueserver.validate_plan.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> bluesky-queueserver
          </a>
              <div class="version">
                0.post1+g64aa1f6
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Basic Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_history.html">Release History</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction_for_users.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="features_and_config.html">Features and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Submitting and Managing Plans</a></li>
<li class="toctree-l1"><a class="reference internal" href="startup_code.html">Organizing Bluesky Startup Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipython.html">Using IPython Startup Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="item_validation.html">Validation of Queue Items</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Annotating Bluesky Plans</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plans-without-annotation-default-behavior">Plans Without Annotation (Default Behavior)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#supported-types">Supported Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-types-in-plan-header">Defining Types in Plan Header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-default-values-in-plan-header">Defining Default Values in Plan Header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameter-descriptions-in-docstring">Parameter Descriptions in Docstring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameter-annotation-decorator">Parameter Annotation Decorator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plan-and-parameter-descriptions">Plan and Parameter Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-types">Parameter Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicitly-enabling-disabling-conversion-of-plan-and-device-names">Explicitly Enabling/Disabling Conversion of Plan and Device Names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-values">Default Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minimum-maximum-and-step-values">Minimum, Maximum and Step Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lists-of-device-and-plan-names">Lists of Device and Plan Names</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lists-of-device-names">Lists of Device Names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lists-of-plan-names">Lists of Plan Names</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plan-annotation-api">Plan Annotation API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.parameter_annotation_decorator.html">bluesky_queueserver.parameter_annotation_decorator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cli_tools.html">Command-Line Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application Developer's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_qs.html">Interacting with Queue Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="re_manager_api.html">Run Engine Manager API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bluesky-queueserver</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Annotating Bluesky Plans</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/plan_annotation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="annotating-bluesky-plans">
<h1>Annotating Bluesky Plans<a class="headerlink" href="#annotating-bluesky-plans" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Queue Server is using information on existing plans and devices stored in
the file <code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code> for validating submitted plans.
The file can be generated using <a class="reference internal" href="cli_tools.html#qserver-list-plans-devices-cli"><span class="std std-ref">qserver-list-plans-devices</span></a> CLI tool or
automatically created/updated by RE Manager (see <a class="reference internal" href="cli_tools.html#update-existing-plans-devices"><span class="std std-ref">Updating the List of Existing Plans and Devices</span></a> for
available options).</p>
<p>Representations of plans generated by <code class="docutils literal notranslate"><span class="pre">qserver-list-plans-devices</span></code> contain items
such as text descriptions of plans and plan parameters, parameter type annotations,
default values and ranges for numerical values. The representations are sufficient
to perform validation of parameters of submitted plans without access to startup
scripts or RE Worker namespace. Plan representations can also be downloaded by
client applications (<a class="reference internal" href="re_manager_api.html#method-plans-allowed"><span class="std std-ref">‘plans_allowed’</span></a> 0MQ API) and used to validate
plan parameters before the plans are submitted to the server. For details on plan
parameter validation see <a class="reference internal" href="item_validation.html#plan-validation"><span class="std std-ref">Validation of Plans</span></a>.
Client applications may also use items such as text descriptions, type annotations,
default values and ranges for generating or annotating user interfaces, such as
GUI forms for plan parameters.</p>
<p>In this manual, the elements of a plan (Python function) header, docstring and
the parameters of the optional <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> that are used
for generating plan representations are referred as <strong>plan annotation</strong>.</p>
<p>All elements in plan annotations are optional. But properly annotating plans may be
beneficial if features such as parameter validation or automated user interface generation
are needed. For example in cases when users are manually entering plan parameter
values in Qt or web forms, it is preferable to detect errors
at the time when the plans are submitted to the queue and reject plans as opposed
to waiting for plans to fail when they are sent for execution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Validation of plan parameters is performed each time a new or modified plan is
submitted to Queue Server. Validation can be also performed on the client side
before the plan is submitted. To run validation, the client must download
the lists of allowed plans and devices  (<a class="reference internal" href="re_manager_api.html#method-plans-allowed"><span class="std std-ref">‘plans_allowed’</span></a> and
<cite>:ref:`method_devices_allowed</cite> 0MQ API) and call <cite>validate_plan()</cite>
(<a class="reference internal" href="item_validation.html#plan-validation-api"><span class="std std-ref">API for Plan Validation</span></a>).</p>
</div>
<p>Plan annotation may contain the following (optional) elements:</p>
<ul class="simple">
<li><p><strong>Description of the plan</strong>: multiline text that describes the plan.
The plan description may be displayed to users by client applications.</p></li>
<li><p><strong>Descriptions for each parameter of the plan</strong>: multiline text that describes
a plan parameter. Separate description is provided for each parameter.
Parameter descriptions may be displayed to users by client applications.</p></li>
<li><p><strong>Type annotations for each parameter</strong>. Parameter types are used
for validation of plan parameters. The types may also be used by client applications
for generating user interfaces.</p></li>
<li><p><strong>Default values for each parameter</strong>. The parameters with defined default values
are optional (following Python rules). The default values are used
for parameter validation. The default values may also be used by client applications
for generating user interfaces.</p></li>
<li><p><strong>Minimum, maximum and step values for each numerical parameter</strong>. The optional
minimum and maximum values define allowed range for numerical parameter values
that is used in parameter validation. Step size is passed to client application
and may be useful in generating user interfaces.</p></li>
</ul>
<p>The elements of plan annotations are defined in the plan header (type hints and
default values) and the docstring (parameter descriptions). In addition, Queue Server
supports <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>),
which allows to define or override any annotation item. The decorator is optional
and should be used only when necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a plan is executed in IPython environment, it behaves as a regular Python
generator function. Only the default values defined in the plan header are used.
Any elements defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> are ignored.</p>
</div>
</section>
<section id="plans-without-annotation-default-behavior">
<span id="plans-without-annotation"></span><h2>Plans Without Annotation (Default Behavior)<a class="headerlink" href="#plans-without-annotation-default-behavior" title="Permalink to this headline">¶</a></h2>
<p>All elements of parameter annotations are optional. Plans without annotations can be
successfully managed by Queue Server. Some of the elements, such as text descriptions
of plans and plan parameters or step values for numerical parameters are not used
by Queue Server, but may be downloaded and used by client applications. The other
elements, such as parameter types and default values are used for plan parameter
validation in Queue Server. All the elements may be downloaded and used by client
applications.</p>
<p>Depending on whether plan annotation contains a default value for a parameter,
the parameter is considered <strong>required</strong> or <strong>optional</strong>. Plans submitted to the queue
must contain values for all required parameters. The default values are used for
missing optional parameters.</p>
<p>For each plan parameter, annotation may contain optional type specification.
All submitted parameter values undergo type validation. For parameter with
type annotation, validation includes verification of the type of the submitted
value based on specified parameter type. The parameters with no type annotations
are treated according to the default rules:</p>
<ul class="simple">
<li><p>Type checking always succeeds, i.e. any submitted value is accepted
and passed to the plan. Plan execution may fail due to incorrect parameter type.</p></li>
<li><p>All strings found in the submitted parameter value (elements of lists, values of
dictionaries, etc.) are matched against the lists of plans and devices allowed for
the user submitting the plan. The matching strings are replaced by references to
respective objects (plans or devices) from RE Worker namespace, all the other strings
are passed as strings.</p></li>
</ul>
<p>The validation algorithm is processing each parameter independently. Type validation
is applied to the parameters with specified type annotation and default rules to
the parameters without specified type.</p>
<p>The examples of the plans with no annotation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plan_demo1a</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
    <span class="c1"># Parameters &#39;npts&#39; and &#39;delay&#39; accept values of any type.</span>
    <span class="c1">#   No type validation is performed on the parameter values.</span>
    <span class="c1">#   The plan may fail during execution if value is not accepted by the plan.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo1b</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Same as &#39;plan_demo1&#39; except the default value for parameter &#39;delay&#39; is</span>
    <span class="c1">#   specified, which makes the parameter &#39;delay&#39; optional.</span>
    <span class="c1">#   No type validation is performed for any parameter.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Queue Server supports plans with parameters accepting references to devices
or other plans. The devices or plans passed as parameters must be defined
in startup scripts, loaded in RE Worker namespace and represented in the list
of existing devices (<code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code>). When submitting
plans to the queue, the devices and plans must be represented by their names
(type <code class="docutils literal notranslate"><span class="pre">str</span></code>). The names are replaced by references to objects in RE Worker
namespace before the parameter values are passed to the plans for execution.
All submitted parameter values are parsed and each string found in the tree
formed by lists, tuples and dictionaries is replaced with a reference to
the matching object. If there is no object with the matching name found or
the name is not in the list of allowed plans or devices for the user
submitting the plan, then the string is not modified and passed directly
to the plan. If the parameter value contains dictionaries, the dictionary
keys are never modified by the algorithm.</p>
<p>The operation of replacing plan and device names with references to objects from RE Worker
namespace is performed for each parameter with no type annotation. This means that
every string that matches a name of a device, subdevice or a plan from the list of allowed
devices or the list of allowed plans is replaced by the reference to the respective object
from RE Worker namespace.</p>
<p>Let’s consider an example of a plan with parameter <code class="docutils literal notranslate"><span class="pre">detectors</span></code> that is expected to
receive a list of detectors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are included in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="k">def</span> <span class="nf">plan_demo1c</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detectors&#39; is expected to receive a list of detectors.</span>
    <span class="c1"># There is no type annotation, so the type is not validated.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If the plan parameters submitted to the queue contain <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det3&quot;]</span></code>,
then the strings <code class="docutils literal notranslate"><span class="pre">&quot;det1&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;det3&quot;</span></code> are replaced with references to objects
<code class="docutils literal notranslate"><span class="pre">det1</span></code> and <code class="docutils literal notranslate"><span class="pre">det3</span></code> and the plan is executed as if it was called from IPython
using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RE</span><span class="p">(</span><span class="n">plan_demo1c</span><span class="p">([</span><span class="n">det1</span><span class="p">,</span> <span class="n">det3</span><span class="p">],</span> <span class="o">&lt;</span><span class="n">value</span> <span class="n">of</span> <span class="n">npts</span><span class="o">&gt;</span><span class="p">))</span>
</pre></div>
</div>
<p>The default behavior, when Queue Server blindly attempts to convert each string found
in each parameter to an object reference may works well in simple cases (especially
in demos). In some applications it may be important to guarantee that strings are
passed as strings regardless on whether the match is found. In those cases
the conversion may be disabled for a given parameter by specifying the parameter type,
e.g. using type hints in the plan header. For example, one may need to pass plan
or device names to the plan:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="k">def</span> <span class="nf">plan_demo1d</span><span class="p">(</span><span class="n">detector_names</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="c1">#   DOES NOT WORK: references to objects are passed to the plan</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo1e</span><span class="p">(</span><span class="n">detector_names</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="c1">#   WORKS: names of detectors are passed without change</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If the value <code class="docutils literal notranslate"><span class="pre">&quot;detector_names&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det3&quot;]</span></code> is passed to the plan <code class="docutils literal notranslate"><span class="pre">plan_demo1d</span></code>,
then the detector names are converted to references. Adding type hint for the parameter
<code class="docutils literal notranslate"><span class="pre">detector_names</span></code> (see <code class="docutils literal notranslate"><span class="pre">plan_demo1e</span></code>) disables string conversion and names are passed
to the plan unchanged. Adding type hint also enables type validation for parameter
<code class="docutils literal notranslate"><span class="pre">detector_names</span></code> and the plan is going to be rejected by Queue Server if the submitted
value is not a list of strings. Type hint may be as restrictive as needed. For example,
type hint <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code> will still disable conversion of strings, but the server will accept
value of any type.</p>
<p>The operation of converting strings to objects never fails. If the device name is
incorrectly spelled or not in the list of allowed plans or devices, then the plan will
be added to the queue and sent for execution. Since the name is passed will be passed
to the plan as a string, the plan will likely fail and the queue is going to be stopped.
For example, assume that <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det4&quot;]</span></code> is passed to
<code class="docutils literal notranslate"><span class="pre">plan_demo1c</span></code>. There is no device named <code class="docutils literal notranslate"><span class="pre">det4</span></code> in the RE Worker namespace, so it will
not be converted to a reference. As a result, the plan will receive the value of
<code class="docutils literal notranslate"><span class="pre">detectors=[det1,</span> <span class="pre">&quot;det4&quot;]</span></code> and fail during execution. Queue Server provides
<code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>), which can be
used to define custom types for advanced parameter validation. In particular, the decorator
allows to define custom enums based on lists of device or plan names and
thus restrict sets of object names that that are accepted by the parameter. Setting
up custom enums with specified lists of plans or devices enables the string conversion,
but only the listed names will be converted to references:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[DevicesType1]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DevicesType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo1f</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The type annotation in the decorator overrides the type annotation in the function header.
Custom enums based on name lists are also used in type validation to guarantee that
only the device/plan names from the defined in the enum are accepted. For example,
if the submitted plan contains <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det4&quot;]</span></code>, then the plan
is rejected, because there is no detector <code class="docutils literal notranslate"><span class="pre">det4</span></code> in the enum type <code class="docutils literal notranslate"><span class="pre">DeviceType1</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Value of any type that is serializable to JSON can be passed to the plan if
the respective parameter type is not defined or defined as <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code>.
In the latter case the server does not attempt to convert strings to object
references.</p>
</div>
</section>
<section id="supported-types">
<span id="id1"></span><h2>Supported Types<a class="headerlink" href="#supported-types" title="Permalink to this headline">¶</a></h2>
<p>Queue Server can process limited number of types used in type annotations and default values.
If a plan header contains parameter unsupported type hint, Queue Server ignores the hint
and the plan is processed as if the parameter contained no type annotation. If unsupported
type annotation is defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>, then processing of the plan
fails and <code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code> can not be generated. The processing also fails
if the default value defined in the plan header or in the decorator has unsupported type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Type annotations and default values defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> override type
annotations and default values defined in the plan header. If type or default value is defined
in the decorator, the respective type and default value from the header are not analyzed.
If it is necessary to define a plan parameter with unsupported type hint or default value
in the header, use <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> to override the type or the default
value in order for the plan processing to work.</p>
</div>
<p><strong>Supported types for type annotations.</strong> Type annotations may be native Python types
(such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, etc.), <code class="docutils literal notranslate"><span class="pre">NoneType</span></code>, or generic types that are based
on native Python types (such as <code class="docutils literal notranslate"><span class="pre">typing.List[typing.Union[int,</span> <span class="pre">str]]</span></code>). Technically the type will
be accepted if the operation of recreating the type object from its string representation
using <code class="docutils literal notranslate"><span class="pre">eval</span></code> function is successful with the namespace that contains imported <code class="docutils literal notranslate"><span class="pre">typing</span></code>
module and <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> type.</p>
<p><strong>Supported types of default values.</strong> The default values can be objects of native Python
types and literal expressions with objects of native Python types. The default value should
be reconstructable with <code class="docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code>, i.e. for the default value <code class="docutils literal notranslate"><span class="pre">vdefault</span></code>,
the operation <code class="docutils literal notranslate"><span class="pre">ast.literal_eval(f&quot;{vdefault!r}&quot;)</span></code> should complete successfully.</p>
<p>The following is an example of a plan with type annotation that discarded by Queue Server.
The type annotation is defined in the plan header, so it is ignored and parameter <code class="docutils literal notranslate"><span class="pre">detector</span></code>
is viewed as having no type annotation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd</span> <span class="kn">import</span> <span class="n">Device</span>

<span class="k">def</span> <span class="nf">plan_demo2a</span><span class="p">(</span><span class="n">detector</span><span class="p">:</span> <span class="n">Device</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Type &#39;Device&#39; is not recognized by Queue Server, because it is imported</span>
    <span class="c1">#   from an external module. Type annotation is ignored by Queue Server.</span>
    <span class="c1">#   Use &#39;parameter_annotation_decorator&#39; to override annotation for</span>
    <span class="c1">#   &#39;detector&#39; if type validation is needed.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In the following example, the type of the default value of the <code class="docutils literal notranslate"><span class="pre">detector</span></code> parameter is not
supported and processing of the plan fails. The issue can be fixed by overriding the default value
using <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span>

<span class="k">def</span> <span class="nf">plan_demo2b</span><span class="p">(</span><span class="n">detector</span><span class="o">=</span><span class="n">det1</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Default value &#39;det1&#39; can not be used with the Queue Server.</span>
    <span class="c1">#   Fix: use &#39;parameter annotation decorator to override the default value.</span>
   <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="defining-types-in-plan-header">
<h2>Defining Types in Plan Header<a class="headerlink" href="#defining-types-in-plan-header" title="Permalink to this headline">¶</a></h2>
<p>Signatures of plans from RE Worker namespace are analyzed each time the list of existing plans
is generated (e.g. by <code class="docutils literal notranslate"><span class="pre">qserver-list-plans-devices</span></code> tool). If a plan signature contains type
hints, the processing algorithm verify if the types are supported and saves their string
representations. Unsupported types are ignored and the respective parameters are treated
as having no type hints (unless type annotations for those parameters are defined in
<code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Queue Server ignores type hints defined in the plan signature for parameters that have
type annotations defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>.</p>
</div>
<p>The acceptable types include Python base types, <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> and imports from <code class="docutils literal notranslate"><span class="pre">typing</span></code> module
(see <a class="reference internal" href="#supported-types"><span class="std std-ref">Supported Types</span></a>). Following are the examples of plans with type hints:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">def</span> <span class="nf">plan_demo3a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type of &#39;detector&#39; is not defined, therefore Queue Server will find and attempt to</span>
    <span class="c1">#   replace all strings passed to this parameter by references to objects in</span>
    <span class="c1">#   RE Worker namespace. Specifying a type hint for the ``detector`` parameter</span>
    <span class="c1">#   would disable the automatic string conversion.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo3b</span><span class="p">(</span><span class="n">positions</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Generic type using the &#39;typing&#39; module. Setting default value to &#39;None&#39;.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo3c</span><span class="p">(</span><span class="n">positions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># This example is precisely identical to the previous example. Both hints are</span>
    <span class="c1">#   converted to &#39;typing.Union[typing.List[float], NoneType]&#39; and</span>
    <span class="c1">#   correctly processed by the Queue Server.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="defining-default-values-in-plan-header">
<h2>Defining Default Values in Plan Header<a class="headerlink" href="#defining-default-values-in-plan-header" title="Permalink to this headline">¶</a></h2>
<p>Follow Python syntax guidelines for defining default values. The type of
the default value must be supported by the Queue Server (see <a class="reference internal" href="#supported-types"><span class="std std-ref">Supported Types</span></a>).
If the default value in the plan header must have unsupported type, override it by
specifying the default value of supported type in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the default value is defined in the <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>,
Queue Server ignores the default value defined in the header. Processing of the plan
fails if the default value for a parameter is defined in the decorator, but
missing in the function header. (A default value in the header is <strong>required</strong>
if the default value is defined in the decorator.)</p>
</div>
</section>
<section id="parameter-descriptions-in-docstring">
<h2>Parameter Descriptions in Docstring<a class="headerlink" href="#parameter-descriptions-in-docstring" title="Permalink to this headline">¶</a></h2>
<p>Queue Server collects text descriptions of the plan and parameters from NumPy-style
docstrings. Type information specified in docstrings is ignored. The example below
shows a plan with a docstring:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plan_demo4a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the description of the plan that could be passed</span>
<span class="sd">    to the client and displayed to users.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : ophyd.Device</span>
<span class="sd">        The detector (Ophyd device). Space is REQUIRED before</span>
<span class="sd">        and after &#39;:&#39; that separates the parameter name and</span>
<span class="sd">        type. Type information is ignored.</span>
<span class="sd">    name</span>
<span class="sd">        Name of the experiment. Type is optional. Queue Server</span>
<span class="sd">        will still successfully process the docstring.</span>
<span class="sd">        Documenting types of all parameters is recommended</span>
<span class="sd">        practice.</span>
<span class="sd">    npts : int</span>
<span class="sd">        Number of experimental points.</span>
<span class="sd">    delay : float</span>
<span class="sd">        Dwell time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="parameter-annotation-decorator">
<span id="id2"></span><h2>Parameter Annotation Decorator<a class="headerlink" href="#parameter-annotation-decorator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#plan-annotation-api"><span class="std std-ref">Plan Annotation API</span></a>) allows to override
any annotation item of the plan, including text descriptions of the plan and parameters,
parameter type annotations and default values. The decorator can be used to define all
annotation items of a plan, but it is generally advised that it is used only when
absolutely necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the default value of a parameter is defined in the decorator, the parameter <strong>must</strong>
have a default value defined in the header. The default values in the decorator and
the header do not have to match. See the use case in
<a class="reference internal" href="#default-values-in-decorator"><span class="std std-ref">notes</span></a>.</p>
</div>
<section id="plan-and-parameter-descriptions">
<h3>Plan and Parameter Descriptions<a class="headerlink" href="#plan-and-parameter-descriptions" title="Permalink to this headline">¶</a></h3>
<p>Text descriptions of plans and parameters are not used by Queue Server and do not
affect processing of plans. In some applications it may be desirable to have
different versions of text descriptions for documentation (e.g. technical description)
and for user interface (e.g. instructions on how to use plans remotely). The decorator
allows to override plan and/or parameter descriptions extracted from the docstring. In this
case the descriptions defined in the decorator are displayed to the user.</p>
<p>All parameters in <cite>parameter_annotation_decorator</cite> are optional. In the following
example, the description for the parameter <cite>npts</cite> is not overridden in the decorator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Plan description displayed to users.&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span>
                <span class="s2">&quot;Description of the parameter &#39;detector&#39;</span><span class="se">\n</span><span class="s2">&quot;</span> \
                <span class="s2">&quot;displayed to Queue Server users&quot;</span><span class="p">,</span>

        <span class="p">}</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span>
                <span class="s2">&quot;Description of the parameter &#39;name&#39;</span><span class="se">\n</span><span class="s2">&quot;</span> \
                <span class="s2">&quot;displayed to Queue Server users&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo4a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plan description, which is part of documentation.</span>
<span class="sd">    It is not visible to Queue Server users.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : ophyd.Device</span>
<span class="sd">        The detector. Technical description,</span>
<span class="sd">        not visible to Queue Server users.</span>
<span class="sd">    name</span>
<span class="sd">        Name of the experiment. Technical description,</span>
<span class="sd">        not visible to Queue Server users.</span>
<span class="sd">    npts : int</span>
<span class="sd">        Number of experimental points.</span>
<span class="sd">        Description remains visible to Queue Server users,</span>
<span class="sd">        because it is not overridden by the decorator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="parameter-types">
<h3>Parameter Types<a class="headerlink" href="#parameter-types" title="Permalink to this headline">¶</a></h3>
<p>Parameter type hints defined in a plan header can be overridden in
<code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>. The type annotations defined in the decorator
do not influence execution of plans in Python. Overriding types should be avoided
whenever possible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Types in the decorator must be represented as string literals. E.g. <code class="docutils literal notranslate"><span class="pre">&quot;str&quot;</span></code>
represents string type, <code class="docutils literal notranslate"><span class="pre">&quot;typing.List[int]&quot;</span></code> represents an array
of integers, etc. Module name <code class="docutils literal notranslate"><span class="pre">typing</span></code> must be explictly used when
defining generic types in the decorator.</p>
</div>
<p>Type annotations defined in the decorator may be used to override unsupported type hints
in plan headers. But the main application of the decorator is to define custom enum types
based on lists of names of plans and devices or string literals. Support for custom enum
types is integrated in functionality of Queue Server, including the functionality such as
type validation and string conversion. If a parameter type defined in the annotation
decorator is using on a custom enum types, which are based on lists of plans or devices,
then all strings passed to the parameter that match the names of plans and devices
in enum definition are converted to references to plans and devices in RE Worker namespace.
The lists of names of plans and devices or string literals may also be used by
client applications to generate user interfaces (e.g. populate combo boxes for selecting
device names).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">ophyd</span> <span class="kn">import</span> <span class="n">Device</span>
<span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span><span class="p">,</span> <span class="n">det4</span><span class="p">,</span> <span class="n">det5</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># &#39;DetectorType1&#39; is the type name (should be a valid Python name)</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;DetectorType1&quot;</span><span class="p">,</span>
            <span class="c1"># &#39;DetectorType1&#39; is defined as custom enum with string values</span>
            <span class="c1">#   &#39;det1&#39;, &#39;det2&#39; and &#39;det3&#39;</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type hint for the parameter &#39;detector&#39; in the header is not required.</span>
    <span class="c1"># Queue Server accepts the plan if &#39;detector&#39; parameter value is</span>
    <span class="c1">#   a string with values &#39;det1&#39;, &#39;det2&#39; or &#39;det3&#39;. The string is</span>
    <span class="c1">#   replaced with the respective reference before the plan is executed.</span>
    <span class="c1">#   Plan validation fails if the parameter value is not in the set.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># Note that type definition is a string !!!</span>
            <span class="c1"># Type names &#39;DetectorType1&#39; and &#39;DetectorType2&#39; are defined</span>
            <span class="c1">#   only for this parameter. The types with the same names</span>
            <span class="c1">#   may be defined differently for the other parameters</span>
            <span class="c1">#   of the plan if necessary, but doing so is not recommended.</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.Union[typing.List[DetectorType1]&quot;</span> \
                          <span class="s2">&quot;typing.List[DetectorType2]]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;DetectorType2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det4&quot;</span><span class="p">,</span> <span class="s2">&quot;det5&quot;</span><span class="p">]},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5b</span><span class="p">(</span><span class="n">detectors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Device</span><span class="p">],</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type hint contains correct Python type that will be passed to the parameter</span>
    <span class="c1">#   before execution.</span>
    <span class="c1"># Queue Server accepta the plan if &#39;detectors&#39; is a list of strings</span>
    <span class="c1">#   from any of the two sets. E.g. [&#39;det1&#39;, &#39;det3&#39;] or [&#39;det4&#39;, &#39;det5&#39;]</span>
    <span class="c1">#   are accepted but [&#39;det2&#39;, &#39;det4&#39;] is rejected (because the</span>
    <span class="c1">#   detectors belong to different lists).</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Similar syntax may be used to define custom enum types for plans (use <code class="docutils literal notranslate"><span class="pre">&quot;plans&quot;</span></code> dictionary key
instead of <code class="docutils literal notranslate"><span class="pre">&quot;devices&quot;</span></code>) or string literals (use <code class="docutils literal notranslate"><span class="pre">&quot;enums&quot;</span></code> dictionary key). The strings listed
as <code class="docutils literal notranslate"><span class="pre">&quot;devices&quot;</span></code> are converted to references to devices and the strings listed as <code class="docutils literal notranslate"><span class="pre">&quot;plans&quot;</span></code>
are converted to references to plans before plan execution. Strings listed under <code class="docutils literal notranslate"><span class="pre">&quot;enums&quot;</span></code>
are not converted to references, but are still used for plan parameter validation.
Mixing devices, plans and enums in one type definition is possible (Queue Server will handle
the types correctly), but not recommended.</p>
<p>The lists of plan and device may contain a mix of explicitly listed plan/device names and
regular expressions used to select plans and devices. See <a class="reference internal" href="#lists-of-device-and-plan-names"><span class="std std-ref">Lists of Device and Plan Names</span></a>
for detailed reference to writing lists of devices and plans.</p>
<p>The decorator supports three built-in types: <code class="docutils literal notranslate"><span class="pre">__PLAN__</span></code>, <code class="docutils literal notranslate"><span class="pre">__DEVICE__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__PLAN_OR_DEVICE__</span></code>. The built-in types are replaced by <code class="docutils literal notranslate"><span class="pre">str</span></code> for type validation and
conversion of plan and/or device names enabled for this parameter. No plan/device lists
are generated and plan/device name is not validated. The built-in types should not be
defined in <code class="docutils literal notranslate"><span class="pre">devices</span></code>, <code class="docutils literal notranslate"><span class="pre">plans</span></code> or <code class="docutils literal notranslate"><span class="pre">enum</span></code> sections of the parameter annotation, since
it is going to be treated as a regular custom enum type.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span><span class="p">,</span> <span class="n">det4</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># &#39;__DEVICE__&#39; is the built-in type. The plan will accept a list of</span>
            <span class="c1"># object names (strings), validate the parameter type and attempt to</span>
            <span class="c1"># convert all string to device objects (not to plans).</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[__DEVICE__]&quot;</span><span class="p">,</span>
            <span class="c1"># If &#39;__DEVICE__&#39; is explicitly defined in the &#39;devices&#39; section,</span>
            <span class="c1"># it will be treated as a custom enum type(only for this parameter).</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5c</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The lists of custom enum types for devices or plans may include any device or plan names
defined in startup scripts and loaded into RE Worker namespace. The type definitions are saved
as part of plan representations in the list of existing plans. If built-in enum types are used,
the definitions will contain full lists of devices from the namespace. When lists of allowed
plans are generated for user groups, custom type definitions are filtered based on user group
permissions, so that only the devices and plans that are allowed for the user group remain.
This allows to use entries from downloaded lists of allowed plans for validation of plans and
for generation of user interfaces directly, without verification user permissions,
since it is guaranteed, that the type definitions contain only devices and plans that the current user
is allowed to use. Filtering type definitions may cause some lists to become empty
in case current user does not have permission to use any devices or plans that are
listed in type definition.</p>
</section>
<section id="explicitly-enabling-disabling-conversion-of-plan-and-device-names">
<span id="enabling-disabling-name-conversion"></span><h3>Explicitly Enabling/Disabling Conversion of Plan and Device Names<a class="headerlink" href="#explicitly-enabling-disabling-conversion-of-plan-and-device-names" title="Permalink to this headline">¶</a></h3>
<p>Parameter annotation allows to specify explicitly whether strings passed to this parameter
are converted to plan or device objects. Optional boolean parameters <code class="docutils literal notranslate"><span class="pre">convert_device_names</span></code>
and <code class="docutils literal notranslate"><span class="pre">convert_plan_names</span></code> override any default behavior. If those parameters are not
specified, then Queue Server determines whether to convert names to objects based on
parameter annotation defined in plan header and <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span><span class="p">,</span> <span class="n">det4</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dets_1&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[str]&quot;</span><span class="p">,</span>
            <span class="c1"># Queue Server attempts to convert each string to a device</span>
            <span class="c1">#   or subdevice from the list of allowed devices.</span>
            <span class="s2">&quot;convert_device_names&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="s2">&quot;dets_2&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[__DEVICE__]&quot;</span><span class="p">,</span>
            <span class="c1"># The device names are not converted to device objects and</span>
            <span class="c1">#   passed to the plan as strings.</span>
            <span class="s2">&quot;convert_device_names&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="s2">&quot;dets_3&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># Device names are going to be converted to device objects.</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[__DEVICE__]&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5d</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameters <code class="docutils literal notranslate"><span class="pre">convert_plan_names</span></code> and <code class="docutils literal notranslate"><span class="pre">convert_device_names</span></code> control only
conversion of plan and device names to objects from the worker namespace
and have no effect on the process of validation of plan parameters.</p>
</div>
</section>
<section id="default-values">
<span id="default-values-in-decorator"></span><h3>Default Values<a class="headerlink" href="#default-values" title="Permalink to this headline">¶</a></h3>
<p>Using decorator to override default values defined in plan header with different values
is possible, but generally not recommended unless absolutely necessary. Overriding the default
value is justified when the type of the default value defined in the header is not supported,
and a different default value of supported type can be defined in the decorator so that
the plan will behave identically when it is executed in Queue Server or IPython environment.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value defined in the decorator must be a Python expression resulting in
the value that satisfy requirements in <a class="reference internal" href="#supported-types"><span class="std std-ref">Supported Types</span></a> (same requirements as
for the default values defined in plan header). For the custom enumerated types, the
default must be one of the valid strings values.</p>
</div>
<p>The following example illustrates the use case which requires overriding the default value.
In this example, the default value for the parameter <code class="docutils literal notranslate"><span class="pre">detector</span></code> is a reference to <code class="docutils literal notranslate"><span class="pre">det1</span></code>,
which has unsupported type (<code class="docutils literal notranslate"><span class="pre">ophyd.Device</span></code>). When submitting the plan to the queue,
the default parameter value must be the string literal <code class="docutils literal notranslate"><span class="pre">&quot;det1&quot;</span></code>, which is then substituted
by reference to <code class="docutils literal notranslate"><span class="pre">det1</span></code>. The decorator contains the definition of custom enum type based
on the list of supported device names and sets the default value as a string representing
the name of one of the supported devices.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;DetectorType1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]},</span>
            <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="s2">&quot;det1&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo6a</span><span class="p">(</span><span class="n">detector</span><span class="o">=</span><span class="n">det1</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># The default value for the parameter &#39;detector&#39; is a reference to &#39;det1&#39;</span>
    <span class="c1">#   when the plan is started from IPython. If the plan is submitted to</span>
    <span class="c1">#   the queue and no value is provided for the parameter &#39;detector&#39;, then</span>
    <span class="c1">#   the parameter is going to be set to string literal value &#39;&quot;det1&quot;&#39;,</span>
    <span class="c1">#   which is then substituted with the reference to the detector &#39;det1&#39;</span>
    <span class="c1">#   before the plan is executed.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</section>
<section id="minimum-maximum-and-step-values">
<h3>Minimum, Maximum and Step Values<a class="headerlink" href="#minimum-maximum-and-step-values" title="Permalink to this headline">¶</a></h3>
<p>The decorator allows to define optional parameters for numeric values passed to plans,
including minimum and maxumum values and step size. The minimum and maximum values determine
the allowed range of numerical values used in parameter validation. Step size is not
used by Queue Server and intended for generating user interfaces in client applications
(e.g. combination of minimum, maximum values and step size may be used to set up a spin box).
If maximum and/or minimum values are defined for a parameter, validation includes checking
if each numerical value in the data structure passed to the parameter is within this range.
The algorithm is searching the data structure for numerical values by iterating through
list elements and dictionary values. Non-numeric values are ignored. Dictionary keys are
not validated.</p>
<p>Setting both minimum and maximum values defines closed range for the parameter value
(including the range boundaries). If only maximum or minimum boundary is set, the range
is limited only from above or below (assuming the missing maximum or minimum
is <code class="docutils literal notranslate"><span class="pre">-Inf</span></code> or <code class="docutils literal notranslate"><span class="pre">Inf</span></code> respectively). If no minimum or maximum value is specified,
then the range is not validated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Minimum, maximum values and step size must be integer or floating point numbers.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="mf">99.9</span><span class="p">,</span>
            <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo7a</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This example defines the range <code class="docutils literal notranslate"><span class="pre">[20,</span> <span class="pre">99.9]</span></code> for the parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>. The plan is accepted
by Queue Server in the following cases:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
<span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mf">20.001</span><span class="p">,</span> <span class="mf">20.002</span><span class="p">]}</span>
<span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">50.5</span><span class="p">,</span> <span class="mf">90.4</span><span class="p">]}}</span>
</pre></div>
</div>
<p>The plan will be rejected if</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>  <span class="c1"># Value 10 is out of range</span>
<span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mf">100.5</span><span class="p">,</span> <span class="mi">90</span><span class="p">]}</span>  <span class="c1"># Value 100.5 is out of range</span>
<span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">}}</span>  <span class="c1"># Value -2 is out of range</span>
<span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">50.5</span><span class="p">,</span> <span class="mf">190.4</span><span class="p">]}}</span>  <span class="c1"># Value 190.4 is out of range</span>
</pre></div>
</div>
</section>
<section id="lists-of-device-and-plan-names">
<span id="id3"></span><h3>Lists of Device and Plan Names<a class="headerlink" href="#lists-of-device-and-plan-names" title="Permalink to this headline">¶</a></h3>
<p>Annotation of a parameter may contain optional <code class="docutils literal notranslate"><span class="pre">devices</span></code> and/or <code class="docutils literal notranslate"><span class="pre">plans</span></code>
sections, which contains lists of device or plan names that could be passed
with the parameter or patterns based on regular expressions used to pick
matching devices or plans from the list of existing devices or plans.
The listed or automatically picked names are converted to objects exisiting
in Run Engine Worker namespace before being passed to the plan. In the
following example there are two lists (<code class="docutils literal notranslate"><span class="pre">Type1</span></code> and <code class="docutils literal notranslate"><span class="pre">Type2</span></code>) defined in
the <code class="docutils literal notranslate"><span class="pre">devices</span></code> section. Names (keys) of the lists are used as types in
the string that defines the parameter type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dets&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.Union[typing.List[Type1]&quot;</span> \
                          <span class="s2">&quot;typing.List[Type2]]&quot;</span><span class="p">,</span>
            <span class="c1"># &quot;det1&quot;, &quot;det2&quot;, &quot;det4&quot; are explicitly stated names</span>
            <span class="c1"># &quot;:det3:?val$&quot;, &quot;:^det5$&quot; are patterns</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Type1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;:det3:?val$&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;Type2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det4&quot;</span><span class="p">,</span> <span class="s2">&quot;:^det5$&quot;</span><span class="p">]},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo8a</span><span class="p">(</span><span class="n">dets</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If a plan accepts reference to other plans defined in the worker
namespace, one of the plan parameters may have a similar section
<code class="docutils literal notranslate"><span class="pre">plans</span></code> with lists of plan names.</p>
<p>Each list may contain a mix of device name and patterns. The processing
algorithm is searching for names of existing plans and devices based
on the patterns and adds them to the lists. After removing Duplicate
names, the lists are sorted in alphabetical order and saved as part
of plan representation in the list of existing plans.</p>
<section id="lists-of-device-names">
<span id="id4"></span><h4>Lists of Device Names<a class="headerlink" href="#lists-of-device-names" title="Permalink to this headline">¶</a></h4>
<p>The elements of lists of device names may include:</p>
<blockquote>
<div><ul class="simple">
<li><p>names of devices defined in the global scope of the startup script,
e.g. <code class="docutils literal notranslate"><span class="pre">&quot;det1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">sim_stage_A</span></code>, etc.</p></li>
<li><p>names of subdevices of devices defined in the global scope of startup script,
e.g. <code class="docutils literal notranslate"><span class="pre">det1.val</span></code>, <code class="docutils literal notranslate"><span class="pre">sim_stageA.mtrs.y</span></code>, etc.</p></li>
<li><p>patterns based on regular expressions for picking devices and subdevices
from the list of existing devices.</p></li>
</ul>
</div></blockquote>
<p>The explicitly listed device and subdevice names are added to the parameter
annotation in the list of existing plans even if such device or plan does
not exist in the worker environment. When plan represenations are preprocessed
before being added to a list of allowed plans, the devices/subdevices/plans
that are not in the list of allowed devices/plans are removed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The following devices will be added to the list:</span>
<span class="c1">#   &#39;det1&#39;</span>
<span class="c1">#   &#39;det1.val&#39;</span>
<span class="c1">#   devices such as &#39;d3&#39;, &#39;det3&#39;, &#39;detector3&#39; etc. matching reg. expression &#39;d.*3&#39;</span>
<span class="s2">&quot;Type3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det1.val&quot;</span><span class="p">,</span> <span class="s2">&quot;:d.*3&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note, that the semicolon <code class="docutils literal notranslate"><span class="pre">:</span></code> is not part of regular expressions and used to
tell the processing algorithm that the string contains a pattern as opposed to
a device or subdevice name. For example, <code class="docutils literal notranslate"><span class="pre">&quot;det&quot;</span></code> is an explicitly listed name
of the detector <code class="docutils literal notranslate"><span class="pre">det</span></code>, while <code class="docutils literal notranslate"><span class="pre">&quot;:det&quot;</span></code> is a regular expression that matches
any device name that contains the sequence of characters <code class="docutils literal notranslate"><span class="pre">&quot;d&quot;,</span> <span class="pre">&quot;e&quot;,</span> <span class="pre">&quot;t&quot;</span></code>,
such as <code class="docutils literal notranslate"><span class="pre">mydetector</span></code>.</p>
<p>A device name pattern may consist of multiple regular expressions separated by
<code class="docutils literal notranslate"><span class="pre">:</span></code>. The expressions are processed from left to right. The leftmost expression
is applied to the name of each device in global worker namespace. If the device
name matches the expression, the device name is added to the list and each
subdevice is checked using the second expression and matching name is added to
the list. The process continues until the end of the pattern or ‘leaf’ devices
(that have no subdevices) are reached. On each step only the subdevices of
matching devices are searched. The maximum depth of search is defined by
the number of expressions in the pattern.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The item contains three regular expressions: &#39;^sim&#39; is applied to device</span>
<span class="c1">#   names (selects all devices starting with &#39;sim&#39;), &#39;^mt&#39; applies to</span>
<span class="c1">#   subdevices of matching devices (all subdevices starting with &#39;mt&#39;)</span>
<span class="c1">#   and &#39;^x$&#39; is applied to subdevices of matching subdevices (all subdevices</span>
<span class="c1">#   named &#39;x&#39;). As a result, the list may contain the following</span>
<span class="c1">#   devices:</span>
<span class="c1">#     &#39;sim_stage_A&#39;</span>
<span class="c1">#     &#39;sim_stage_A.mtrs&#39;,</span>
<span class="c1">#     &#39;sim_stage_A.mtrs.x&#39;,</span>
<span class="c1">#     &#39;sim_stage_B&#39;.</span>
<span class="c1">#     &#39;sim_stage_B.mtrs&#39;.</span>
<span class="c1">#     &#39;sim_stage_B.mtrs.x&#39;.</span>
<span class="s2">&quot;Type3&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:^sim:^mt:^x$&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The default behavior of the list generation algorithm is to include in the list
all matching devices and subdevices found at each level. The algorithm can be
explicitly instructed to do so by inserting <code class="docutils literal notranslate"><span class="pre">+</span></code> (plus sign) before the regular
expression, i.e. the patterns <code class="docutils literal notranslate"><span class="pre">&quot;:^det.val$</span></code>” and <code class="docutils literal notranslate"><span class="pre">&quot;&quot;:+^det.val$&quot;</span></code> would
produce identical results. The default behavior is not always desirable. In order
to skip adding to the list matching devices found at a given depth, add <code class="docutils literal notranslate"><span class="pre">-</span></code>
(minus sign) before the regular expression (<code class="docutils literal notranslate"><span class="pre">:-</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The list will contain devices such as</span>
<span class="c1">#   &#39;sim_stage_A.mtrs&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.mtrs.x&#39;,</span>
<span class="c1">#   &#39;sim_stage_B.mtrs&#39;,</span>
<span class="c1">#   &#39;sim_stage_B.mtrs.x&#39;.</span>
<span class="s2">&quot;Type4&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:-^sim:^mt:^x$&quot;</span><span class="p">]</span>

<span class="c1"># The list will contain devices such as</span>
<span class="c1">#   &#39;sim_stage_A.mtrs.x&#39;,</span>
<span class="c1">#   &#39;sim_stage_B.mtrs.x&#39;.</span>
<span class="s2">&quot;Type5&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:-^sim:-^mt:-^x$&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note, that even though <code class="docutils literal notranslate"><span class="pre">-</span></code> is allowed in the last expression of the pattern,
it does not influence processing of the pattern. The devices matching the last
expression in the pattern are always inserted in the list.</p>
<p>Regular expressions could be applied to the full device name (such as
<code class="docutils literal notranslate"><span class="pre">&quot;sim_stage_A.mtrs.x&quot;</span></code>) or right part a full device name (such as <code class="docutils literal notranslate"><span class="pre">&quot;mtrs.x&quot;</span></code>).
An expression may be labelled as a full-name expression by putting <code class="docutils literal notranslate"><span class="pre">?</span></code>
(question mark) before the regular expression. The full name regular expression
may only be the last component of the pattern. :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The list may contain devices with names such as</span>
<span class="c1">#   &#39;simval&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.det1.val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.detectors.det1.val&#39;,</span>
<span class="s2">&quot;Type6&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:?^sim.*val$&quot;</span><span class="p">]</span>

<span class="c1"># The list will contain devices such as</span>
<span class="c1">#   &#39;sim_stage_A&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.det1_val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.det1.val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.detectors.det1.val&#39;,</span>
<span class="s2">&quot;Type7&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:^sim_stage_A$:?.*val$&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note, that <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> can not be used in conjunction with <code class="docutils literal notranslate"><span class="pre">?</span></code>.
Using full-name expressions is less efficient, since it the algorithm
is forced to searching the full tree of subdevices for matching names.
The depth of search may be explicitly limited by adding <code class="docutils literal notranslate"><span class="pre">depth</span></code>
parameter (<code class="docutils literal notranslate"><span class="pre">:?&lt;regex&gt;:depth=N</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The list will contain devices such as</span>
<span class="c1">#   &#39;sim_stage_A&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.det1_val&#39;,</span>
<span class="c1">#   &#39;sim_stage_A.det1.val&#39;,</span>
<span class="c1"># The list will not contain &#39;sim_stage_A.detectors.det1.val&#39;,</span>
<span class="c1">#   since the depth of search is limited to 2 levels.</span>
<span class="s2">&quot;Type8&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;:+^sim_stage_A$:?.*val$:depth=2&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>A set of devices matching a pattern may be restricted to devices of certain
types by placing one of the type keywords before the patter. The supported
keywords are <code class="docutils literal notranslate"><span class="pre">__DETECTOR__</span></code> (readable, not movable), <code class="docutils literal notranslate"><span class="pre">__MOTOR__</span></code>
(readable and movable), <code class="docutils literal notranslate"><span class="pre">__READABLE__</span></code>, <code class="docutils literal notranslate"><span class="pre">__FLYABLE__</span></code> before the expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select only detectors with names matching the regular expression:</span>
<span class="s2">&quot;Type9&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;__DETECTORS__:^sim_stage_A$:?.*:depth=3&quot;</span><span class="p">]</span>

<span class="c1"># Select only motors:</span>
<span class="s2">&quot;Type10&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;__MOTORS__:^sim_stage_A$:?.*:depth=3&quot;</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="lists-of-plan-names">
<span id="id5"></span><h4>Lists of Plan Names<a class="headerlink" href="#lists-of-plan-names" title="Permalink to this headline">¶</a></h4>
<p>Similarly to lists of device names, the lists of plan names may include
patterns used to pick matching names of the existing plans:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The list contains the following names: explicitly listed name of the plan</span>
<span class="c1">#   ``count`` and regular expression that selects all the plans ending</span>
<span class="c1">#   with ``_count``, such as ``_count``, ``my_count`` etc.</span>
<span class="s2">&quot;Type11&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;:_count$&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>A plan name pattern may contain only a single regular expression (i.e.
a pattern may contain only one <code class="docutils literal notranslate"><span class="pre">:</span></code> character). The modifiers <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>
and <code class="docutils literal notranslate"><span class="pre">?</span></code> may still be used, but the do not influence processing
of the plan name patterns (they are allowed to make patterns for plans
and devices look uniform, but since plan patterns contain only one component
and this component is the last, the matching plan names are always added
to the list and the regular expression is always applied to the full name).
<strong>Device type keywords can not be used in plan name patterns.</strong></p>
</section>
</section>
</section>
<section id="plan-annotation-api">
<span id="id6"></span><h2>Plan Annotation API<a class="headerlink" href="#plan-annotation-api" title="Permalink to this headline">¶</a></h2>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.parameter_annotation_decorator.html#bluesky_queueserver.parameter_annotation_decorator" title="bluesky_queueserver.parameter_annotation_decorator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code></a></p></td>
<td><p>The decorator allows to attach a custom description to a function or generator function.</p></td>
</tr>
</tbody>
</table>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="generated/bluesky_queueserver.validate_plan.html" class="btn btn-neutral float-left" title="bluesky_queueserver.validate_plan" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="generated/bluesky_queueserver.parameter_annotation_decorator.html" class="btn btn-neutral float-right" title="bluesky_queueserver.parameter_annotation_decorator" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, Brookhaven National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>