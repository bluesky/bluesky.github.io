<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Using the Queue Server &mdash; bluesky-queueserver 0.0.19.post55+g60a928e documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css?v=0c24fe83" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/documentation_options.js?v=1773ddd3"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Features and Configuration" href="features_and_config.html" />
    <link rel="prev" title="Introduction" href="introduction_for_users.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            bluesky-queueserver
          </a>
              <div class="version">
                0.0.19.post55+g60a928e
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/bluesky/bluesky-queueserver">Source Code on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction_for_users.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using the Queue Server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#starting-and-stopping-run-engine-manager">Starting and Stopping Run Engine Manager</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#running-re-manager-as-an-application">Running RE Manager as an Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-re-manager-as-a-service">Running RE Manager as a Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#closing-re-manager-using-api">Closing RE Manager using API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#monitoring-of-status-of-re-manager">Monitoring of Status of RE Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#opening-and-closing-re-worker-environment">Opening and Closing RE Worker Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-the-plan-queue">Managing the Plan Queue</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-the-plan-history">Managing the Plan History</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-execution-of-the-queue-and-the-plans">Controlling Execution of the Queue and the Plans</a></li>
<li class="toctree-l2"><a class="reference internal" href="#immediate-execution-of-plans">Immediate Execution of Plans</a></li>
<li class="toctree-l2"><a class="reference internal" href="#executing-functions">Executing Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uploading-scripts">Uploading Scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-tasks">Running Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#locking-re-manager">Locking RE Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#queue-autostart-mode">Queue Autostart Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-re-worker-with-ipython-kernel">Running RE Worker with IPython Kernel</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#starting-re-manager-in-ipython-mode">Starting RE Manager in IPython Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-ipython-kernel-ip-address">Specifying IPython Kernel IP Address</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-location-of-startup-code">Specifying Location of Startup Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-matplotlib-backend">Setting Matplotlib Backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monitoring-the-state-of-ipython-kernel">Monitoring the State of IPython Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#downloading-kernel-connection-info">Downloading Kernel Connection Info</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-to-running-ipython-kernel-using-jupyter-console">Connecting to Running IPython Kernel Using Jupyter Console</a></li>
<li class="toctree-l3"><a class="reference internal" href="#updating-the-worker-environment-cache">Updating the Worker Environment Cache</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interrupting-the-ipython-kernel">Interrupting the IPython Kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="features_and_config.html">Features and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="startup_code.html">Organizing Bluesky Startup Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipython.html">Using IPython Startup Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="item_validation.html">Validation of Queue Items</a></li>
<li class="toctree-l1"><a class="reference internal" href="plan_annotation.html">Annotating Bluesky Plans</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli_tools.html">Command-Line Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="manager_config.html">RE Manager Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="qserver_quick_ref.html"><em>qserver</em> : Quick Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application Developer's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_qs.html">Interacting with Queue Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="re_manager_api.html">Run Engine Manager API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Related Projects</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-queueserver-api">Bluesky Queue Server API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-httpserver">Bluesky HTTP Server</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-widgets">Bluesky Widgets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky">Bluesky</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/ophyd">Ophyd</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/databroker">Data Broker</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bluesky-queueserver</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Using the Queue Server</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/using_queue_server.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="using-the-queue-server">
<h1>Using the Queue Server<a class="headerlink" href="#using-the-queue-server" title="Link to this heading">¶</a></h1>
<section id="starting-and-stopping-run-engine-manager">
<h2>Starting and Stopping Run Engine Manager<a class="headerlink" href="#starting-and-stopping-run-engine-manager" title="Link to this heading">¶</a></h2>
<p>The core component of the Queue Server is the Run Engine manager, which could be started as an application
or a service. Running RE Manager as an application is easy and recommended for evaluation, testing and demos.
Production systems more likely to run RE Manager as a service.</p>
<section id="running-re-manager-as-an-application">
<span id="running-re-manager-as-application"></span><h3>Running RE Manager as an Application<a class="headerlink" href="#running-re-manager-as-an-application" title="Link to this heading">¶</a></h3>
<p>Starting RE Manager as an application is demonstrated in tutorials <a class="reference internal" href="tutorials.html#tutorial-starting-queue-server"><span class="std std-ref">Starting the Queue Server</span></a> and
<a class="reference internal" href="tutorials.html#tutorial-starting-queue-server"><span class="std std-ref">Starting the Queue Server</span></a> and includes activating the Conda environment with installed Queue Server
and running <a class="reference internal" href="cli_tools.html#start-re-manager-cli"><span class="std std-ref">start-re-manager</span></a> with appropriate set of parameters. Activating some options may also
require environment variables to be set before <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code> is started.</p>
<p>RE Manager is started with the default set of options by typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ start-re-manager
</pre></div>
</div>
<p>in the command prompt. The default options are sufficient for most demos, which are based on the simulated
startup code distributed with the package. If a demo involves remote monitoring of console output,
then activate publishing of console output to 0MQ socket by using <code class="docutils literal notranslate"><span class="pre">--zmq-publish-console</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ start-re-manager --zmq-publish-console ON
</pre></div>
</div>
<p>The manager could be configured to load custom startup code by setting the path to the directory with
code files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ start-re-manager --zmq-publish-console ON --startup-dir &lt;path-to-directory-with-files&gt;
</pre></div>
</div>
<p>RE Manager automaticaly creates instances of Bluesky Run Engine (<code class="docutils literal notranslate"><span class="pre">RE</span></code>) and Data Broker (<code class="docutils literal notranslate"><span class="pre">db</span></code>).
Production scripts typically create custom instances <code class="docutils literal notranslate"><span class="pre">RE</span></code> and <code class="docutils literal notranslate"><span class="pre">db</span></code>. In this case, RE Manager
must be called with the option <code class="docutils literal notranslate"><span class="pre">--keep-re</span></code> to prevent RE Manager from overriding <code class="docutils literal notranslate"><span class="pre">RE</span></code> and <code class="docutils literal notranslate"><span class="pre">db</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ start-re-manager --zmq-publish-console ON --startup-dir &lt;path-to-directory-with-files&gt; --keep-re
</pre></div>
</div>
<p>This is the minimum configuration of RE Manager sufficient for practical use of Queue Server for experimental
control. Configuring RE Manager for a production system may require additiona settings. See <a class="reference internal" href="cli_tools.html#start-re-manager-cli"><span class="std std-ref">start-re-manager</span></a>
for detailed description of parameters.</p>
<p>Run Engine manager running as an application may be closed by pressing Ctrl-C in the terminal.</p>
</section>
<section id="running-re-manager-as-a-service">
<h3>Running RE Manager as a Service<a class="headerlink" href="#running-re-manager-as-a-service" title="Link to this heading">¶</a></h3>
<p>The following example demonstrates how to start RE Manager as a user service, which does not
require root access. The manager is started in the most basic configuration. Change the configuration
by setting by setting environment variables and additional parameters of <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code> as needed.
Setting up the service requires two files: service configuration file and the script that starts
RE Manager. Replace <code class="docutils literal notranslate"><span class="pre">&lt;user-name&gt;</span></code> in file paths and the script files with the correct user name.
It is also assumed that the Queue Server is installed in <em>bs-qserver</em> environment using <em>miniconda3</em>.
Modify the scripts and paths to reflect the system configuration.</p>
<p>Service configuration file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># File: /home/&lt;user-name&gt;/.config/systemd/user/queue-server.service</span>

<span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">Description</span><span class="o">=</span><span class="n">Bluesky</span> <span class="n">Queue</span> <span class="n">Server</span>

<span class="p">[</span><span class="n">Service</span><span class="p">]</span>
<span class="n">ExecStart</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">bash</span> <span class="o">/</span><span class="n">home</span><span class="o">/&lt;</span><span class="n">user</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;/</span><span class="n">queue</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">sh</span>

<span class="p">[</span><span class="n">Install</span><span class="p">]</span>
<span class="n">WantedBy</span><span class="o">=</span><span class="n">default</span><span class="o">.</span><span class="n">target</span>
<span class="n">Alias</span><span class="o">=</span><span class="n">queue</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">service</span>
</pre></div>
</div>
<p>The script for starting RE Manager:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># File: /home/&lt;user-name&gt;/queue-server.sh</span>

<span class="n">source</span> <span class="s2">&quot;/home/dgavrilov/miniconda3/etc/profile.d/conda.sh&quot;</span>
<span class="n">conda</span> <span class="n">activate</span> <span class="n">bs</span><span class="o">-</span><span class="n">qserver</span>
<span class="n">start</span><span class="o">-</span><span class="n">re</span><span class="o">-</span><span class="n">manager</span> <span class="o">--</span><span class="n">zmq</span><span class="o">-</span><span class="n">publish</span><span class="o">-</span><span class="n">console</span> <span class="n">ON</span> <span class="o">--</span><span class="n">console</span><span class="o">-</span><span class="n">output</span> <span class="n">OFF</span>
</pre></div>
</div>
<p>Starting the service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`$ systemctl --user start queue-server
</pre></div>
</div>
<p>Checking the status of the service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`$ systemctl --user status queue-server
</pre></div>
</div>
<p>Stopping the service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`$ systemctl --user stop queue-server
</pre></div>
</div>
<p>The Run Manager is configured not to print any console output, but instead to publish console output to
0MQ socket. See the section <a class="reference internal" href="features_and_config.html#remote-monitoring-of-console-output"><span class="std std-ref">Remote Monitoring of Console Output</span></a> and the tutorial
<a class="reference internal" href="tutorials.html#tutorial-remote-monitoring"><span class="std std-ref">Remote Monitoring of RE Manager Console Output</span></a> for the instructions on how to view the console output remotely.
The illustrated procedure can be modified to satisfy practical operational needs.</p>
</section>
<section id="closing-re-manager-using-api">
<h3>Closing RE Manager using API<a class="headerlink" href="#closing-re-manager-using-api" title="Link to this heading">¶</a></h3>
<p>RE Manager can be stopped programmatically by sending <a class="reference internal" href="re_manager_api.html#method-manager-stop"><span class="std std-ref">‘manager_stop’</span></a> API request. The API parameter
allows to select whether the operation is performed in <em>safe</em> mode (API request is rejected if RE Manager is
not <em>idle</em>) or to disable safe mode (RE Manager is closed even if it is performing an operation, e.g. a plan
is running). The API is mostly intended for automated system testing and should not be exposed to general users
through client applications.</p>
</section>
</section>
<section id="monitoring-of-status-of-re-manager">
<h2>Monitoring of Status of RE Manager<a class="headerlink" href="#monitoring-of-status-of-re-manager" title="Link to this heading">¶</a></h2>
<p>Status of RE Manager may be loaded at any time using <a class="reference internal" href="re_manager_api.html#method-status"><span class="std std-ref">‘status’</span></a> API. The API returns
a dictionary with status parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;devices_allowed_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;0639bc7a-15c1-4bc2-bfeb-41f58a08a8b9&#39;</span><span class="p">,</span>
<span class="s1">&#39;devices_existing_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;2fe9df70-5f0f-4c17-bb7b-cda8a0aa80b0&#39;</span><span class="p">,</span>
<span class="s1">&#39;items_in_history&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="s1">&#39;items_in_queue&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="s1">&#39;lock&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;environment&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;queue&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="s1">&#39;lock_info_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;2b438226-f715-4ed3-a057-400a42717bb0&#39;</span><span class="p">,</span>
<span class="s1">&#39;manager_state&#39;</span><span class="p">:</span> <span class="s1">&#39;idle&#39;</span><span class="p">,</span>
<span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;RE Manager v0.0.16.post28.dev0+ge2491ae&#39;</span><span class="p">,</span>
<span class="s1">&#39;pause_pending&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
<span class="s1">&#39;plan_history_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;5894c896-b2ea-42c1-9dd0-f4faaa52cb39&#39;</span><span class="p">,</span>
<span class="s1">&#39;plan_queue_mode&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;loop&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="s1">&#39;plan_queue_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;5589b7ac-01b9-4f51-a7f2-8e883c352053&#39;</span><span class="p">,</span>
<span class="s1">&#39;plans_allowed_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;835a998a-e01e-439f-bb3a-b65817904f7a&#39;</span><span class="p">,</span>
<span class="s1">&#39;plans_existing_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;609ec025-2552-4e06-aa54-5e9ae7b7ed2c&#39;</span><span class="p">,</span>
<span class="s1">&#39;queue_stop_pending&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
<span class="s1">&#39;re_state&#39;</span><span class="p">:</span> <span class="s1">&#39;idle&#39;</span><span class="p">,</span>
<span class="s1">&#39;run_list_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;0b088775-1cc3-46de-9563-b83e04c0e243&#39;</span><span class="p">,</span>
<span class="s1">&#39;running_item_uid&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="s1">&#39;task_results_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;846b6dd3-d9c2-4a12-bd03-b82580b8f742&#39;</span><span class="p">,</span>
<span class="s1">&#39;worker_background_tasks&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="s1">&#39;worker_environment_exists&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;worker_environment_state&#39;</span><span class="p">:</span> <span class="s1">&#39;idle&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>The parameter <em>msg</em> contains the version information on currently running RE Manager. The states
of RE Manager and Run Engine are returned using parameters <em>manager_state</em> and <em>re_state</em>.
The latter represents true state of Run Engine that is is propagated from RE Worker environment
(there could be some short delay before the state is updated). The boolean parameter
<em>worker_environment_exists</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the environment is opened and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>Parameters with names ending with <em>‘_uid’</em> (such as <em>plan_queue_uid</em>) contain UIDs of the respective
objects that are changed each time the objects are updated. For example, <em>plan_queue_uid</em> is changed
each time the queue is updated either in response to API request from a client or due to internal
processes. Tracking changes in UIDs and downloading the respective objects only when the UIDs
change is more efficient than continuously polling the objects themselves.</p>
<p>See documentation on <a class="reference internal" href="re_manager_api.html#method-status"><span class="std std-ref">‘status’</span></a> API for detailed description of the status parameters.</p>
</section>
<section id="opening-and-closing-re-worker-environment">
<h2>Opening and Closing RE Worker Environment<a class="headerlink" href="#opening-and-closing-re-worker-environment" title="Link to this heading">¶</a></h2>
<p>The RE Worker environment must be opened before starting the queue, executing plans, functions or uploading script.
The operation of opening the environment consists of creating a separate process (Worker process) and loading
startup code. Once startup code is loaded, RE Manager updates the lists of existing and allowed devices and plans
based on the contents of the Worker namespace. The process of opening the environment is initiated by sending
<a class="reference internal" href="re_manager_api.html#method-environment-open"><span class="std std-ref">‘environment_open’</span></a> API request and if the request is accepted, then waiting for the process to complete.</p>
<p>The contents of the environment may be changed remotely by uploading and executing scripts using
<a class="reference internal" href="re_manager_api.html#method-script-upload"><span class="std std-ref">‘script_upload’</span></a> API, which allows to add, remove or modify objects in the worker namespace.
The changes introduced by uploaded scripts are lost once the environment is closed.</p>
<p>Similarly to opening the environment, the operation of closing or destroying the environment is initiated by sending
<a class="reference internal" href="re_manager_api.html#method-environment-close"><span class="std std-ref">‘environment_close’</span></a> or <a class="reference internal" href="re_manager_api.html#method-environment-destroy"><span class="std std-ref">‘environment_destroy’</span></a> API requests and waiting for operation to
complete. The <a class="reference internal" href="re_manager_api.html#method-environment-close"><span class="std std-ref">‘environment_close’</span></a> API is intended for use during normal operation. The environment
can be closed only if RE Manager is idle, i.e. no plans or tasks are currently executed. The operation of destroying
the environment allows to recover RE Manager in case the environment is stuck (e.g. executing an infinite loop)
by killing the worker process. The operation is unsafe and should be used only as a last resort.</p>
<p>See the tutorial <a class="reference internal" href="tutorials.html#tutorial-opening-closing-re-worker-environment"><span class="std std-ref">Opening and Closing RE Worker Environment</span></a>.</p>
</section>
<section id="managing-the-plan-queue">
<h2>Managing the Plan Queue<a class="headerlink" href="#managing-the-plan-queue" title="Link to this heading">¶</a></h2>
<p>RE Manager supports operations on the queue allowing clients to add, move, remove and replace queue items.
All queue operations may be executed at any time. The contents of the queue may be loaded using
<a class="reference internal" href="re_manager_api.html#method-queue-get"><span class="std std-ref">‘queue_get’</span></a> API, which returns the list queue items (<em>items</em>) and the currently running item
(<em>running_item</em>) if the queue is running. The running item is not considered part of the queue and can
not be used in most of the queue operations.</p>
<p>The queue supports two types of items: plans (Bluesky plans executed in the worker environment)
and instructions. The instructions are used to control the queue. Currently only one instruction
(<code class="docutils literal notranslate"><span class="pre">'queue_stop'</span></code>) instruction is supported.</p>
<p>The operations of adding (<a class="reference internal" href="re_manager_api.html#method-queue-item-add"><span class="std std-ref">‘queue_item_add’</span></a>), moving (<a class="reference internal" href="re_manager_api.html#method-queue-item-move"><span class="std std-ref">‘queue_item_move’</span></a>) and removing
(<a class="reference internal" href="re_manager_api.html#method-queue-item-remove"><span class="std std-ref">‘queue_item_remove’</span></a>) items have batch equivalents <a class="reference internal" href="re_manager_api.html#method-queue-item-add-batch"><span class="std std-ref">‘queue_item_add_batch’</span></a>,
<a class="reference internal" href="re_manager_api.html#method-queue-item-move-batch"><span class="std std-ref">‘queue_item_move_batch’</span></a> and <a class="reference internal" href="re_manager_api.html#method-queue-item-remove-batch"><span class="std std-ref">‘queue_item_remove_batch’</span></a>. The batch operations accept lists
of items instead of single items and guaranteed to perform atomic operations on the queue.</p>
<p>Queue operations allow multiple modes of addressing queue items. Items may be addressed using item position
(parameter <code class="docutils literal notranslate"><span class="pre">pos</span></code>), which could be positive or negative index of the item or a string literal (<code class="docutils literal notranslate"><span class="pre">'front'</span></code>
or <code class="docutils literal notranslate"><span class="pre">'back'</span></code>). While using <code class="docutils literal notranslate"><span class="pre">pos='front'</span></code> or <code class="docutils literal notranslate"><span class="pre">pos='back'</span></code> to insert or move items to the front or back of
the queue is guaranteed to produce the expected result, using indexes is reliable only if the queue is not
running (negative indexes should work reliably if the queue is running) and no other clients are in
the process of modifying the queue. Another mode of addressing is using item UID to uniquiely identify
the queue items. Queue operations allow to select items by UID and insert items before or after items with
a given UID (parameters <code class="docutils literal notranslate"><span class="pre">uid</span></code>, <code class="docutils literal notranslate"><span class="pre">before_uid</span></code> and <code class="docutils literal notranslate"><span class="pre">after_uid</span></code>). Batch operations accept lists of
item UIDs (parameter <code class="docutils literal notranslate"><span class="pre">uids</span></code>) to select and possibly reorder lists of existing items.</p>
<p>The queue may be cleared at any time using <a class="reference internal" href="re_manager_api.html#method-queue-clear"><span class="std std-ref">‘queue_clear’</span></a> API. If the queue is running, clearing
the queue does not affect currently running item or the state of the queue: if no new items are added
by the time the currently running plan is completed, then the queue is automatically stopped.</p>
<p>See the full list of API in <a class="reference internal" href="re_manager_api.html#supported-methods-for-0mq-api"><span class="std std-ref">Supported Methods For ZMQ Communication API</span></a> and tutorial <a class="reference internal" href="tutorials.html#tutorial-adding-queue-items"><span class="std std-ref">Adding Items to Queue</span></a>.</p>
</section>
<section id="managing-the-plan-history">
<h2>Managing the Plan History<a class="headerlink" href="#managing-the-plan-history" title="Link to this heading">¶</a></h2>
<p>Plan history contains a list of completed plans along with the results of execution (start and stop time,
completion status, error message and traceback in case of failure). The plan history may be loaded using
<a class="reference internal" href="re_manager_api.html#method-history-get"><span class="std std-ref">‘history_get’</span></a> API and cleared using <a class="reference internal" href="re_manager_api.html#method-history-clear"><span class="std std-ref">‘history_clear’</span></a> API. Plan history is not designed
to grow indefinitely and should be periodically cleared in order to avoid performance issues.</p>
</section>
<section id="controlling-execution-of-the-queue-and-the-plans">
<h2>Controlling Execution of the Queue and the Plans<a class="headerlink" href="#controlling-execution-of-the-queue-and-the-plans" title="Link to this heading">¶</a></h2>
<p>The plan queue can be started using <a class="reference internal" href="re_manager_api.html#method-queue-start"><span class="std std-ref">‘queue_start’</span></a> if RE Worker environment is open, otherwise
the API request fails. The queue stops automatically once it runs out of plans. Users may request RE Manager
to stop the queue by sending <a class="reference internal" href="re_manager_api.html#method-queue-stop"><span class="std std-ref">‘queue_stop’</span></a> API request. Once RE Manager receives the request,
it waits until the currently executed plan is completed and then stops the queue. The pending request
to stop the queue is reflected in RE Manager status (<em>queue_stop_pending</em>) and may be cancelled at any time
while the queue is still running by sending <a class="reference internal" href="re_manager_api.html#method-queue-stop-cancel"><span class="std std-ref">‘queue_stop_cancel’</span></a> request.</p>
<p>The alternative way to stop the queue is to add <code class="docutils literal notranslate"><span class="pre">'queue_stop'</span></code> instruction to the desired position in
the queue. RE Manager pops the instruction from the queue and stops the execution. The queue execution may
be resumed at any time starting from the following item.</p>
<p>Execution of the currently running plan can be interrupted using <a class="reference internal" href="re_manager_api.html#method-re-pause"><span class="std std-ref">‘re_pause’</span></a> API request.
The API allows to request deferred (the plan runs until the next checkpoint) or immediate pause.
See <a class="reference external" href="https://blueskyproject.io/bluesky/state-machine.html">Interruptions</a> sections of Bluesky documentation
for more details. The paused plan may be <a class="reference internal" href="re_manager_api.html#method-re-resume-stop-abort-halt"><span class="std std-ref">resumed, stopped, aborted or halted</span></a>.
Note, that stopped plan is considered successfully completed, while aborted and halted plans are considered
failed.</p>
<p>Interrupting the current plan allows to stop the queue immediately: the plan may be paused by sending
<a class="reference internal" href="re_manager_api.html#method-re-pause"><span class="std std-ref">‘re_pause’</span></a> API request (this will pause the execution of the plan, which may be sufficient to resolve
some technical difficulties) and then stop using <a class="reference internal" href="re_manager_api.html#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_stop’</span></a>
or abort using <a class="reference internal" href="re_manager_api.html#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_abort’</span></a> API (the latter API pushes the plan to
the top of the queue).</p>
<p>The queue can operate with enabled/disabled <em>LOOP</em> mode (see <a class="reference internal" href="re_manager_api.html#method-queue-mode-set"><span class="std std-ref">‘queue_mode_set’</span></a>). If the <em>LOOP</em> mode
is disabled (normal mode), the items are popped from the front of the queue and executed by in the Worker
(plans) or the manager (instructions). The successfully completed plans (including stopped plans) are
permanently removed from the queue and added to plan history upon completion. If a plan fails, is aborted
and or halted, it is pushed to the front of the queue and added to the history along with execution results
(error message and traceback) and the queue execution is automatically stopped. This behavior may be changed
by enabling <em>IGNORE_FAILURES</em> mode, in which the server proceeds with execution of the next plan in the queue
even after the current plan fails. The operation is slightly different if the <em>LOOP</em> mode is enabled:
successfully executed (or stopped) plans and instructions are added to the back of the queue, allowing
client to infinitely repeate a sequence of plans. The stopped plans are treated as successful in all modes.
Stopping a plan also stops execution of the queue.</p>
<p>See the tutorials <a class="reference internal" href="tutorials.html#tutorial-starting-stopping-queue"><span class="std std-ref">Starting and Stopping the Queue</span></a> and <a class="reference internal" href="tutorials.html#tutorial-iteracting-with-run-engine"><span class="std std-ref">Interacting with Run Engine</span></a>.</p>
</section>
<section id="immediate-execution-of-plans">
<span id="id1"></span><h2>Immediate Execution of Plans<a class="headerlink" href="#immediate-execution-of-plans" title="Link to this heading">¶</a></h2>
<p>RE Manager allows to execute plans without placing them in the queue. Plans can be submitted for
immediate execution using <a class="reference internal" href="re_manager_api.html#method-queue-item-execute"><span class="std std-ref">‘queue_item_execute’</span></a> API. The requests are accepted only if
RE Manager is in the idle state, otherwise the request is rejected and the plan is discarded.
Once the request is validated and accepted, the plan is passed to RE Worker for immediate
execution. Similarly to items from the queue, the plan is assigned item UID and can be tracked
using the same API. Upon completion, the plan is added to history along with the results of
execution. The plan is never added to the queue, even if it fails or the queue is in the loop
mode. If the queue contains other plans, its contents remain unchanged. Submitting a plan
for immediate execution does not start execution of the existing queue.</p>
<p>See the tutorial <a class="reference internal" href="tutorials.html#tutorial-immediate-execution-of-plans"><span class="std std-ref">Immediate Execution of Plans</span></a>.</p>
</section>
<section id="executing-functions">
<span id="id2"></span><h2>Executing Functions<a class="headerlink" href="#executing-functions" title="Link to this heading">¶</a></h2>
<p>RE Manager allows to start execution functions in RE Worker environment. The requests to start
execution of functions could be submitted by clients using <a class="reference internal" href="re_manager_api.html#method-function-execute"><span class="std std-ref">‘function_execute’</span></a> API,
which accepts function name and parameters in the format used for queue item. Clients may
access only functions that exist in RE Worker namespace (e.g. defined in startup script or
an uploaded script) and allowed by user group permissions (see <a class="reference internal" href="features_and_config.html#configuring-user-group-permissions"><span class="std std-ref">Configuring User Group Permissions</span></a>).
The functions may access all objects in the namespace and used to change states of the objects
or read the states of the objects and return the results to the client. While it is possible
to corrupt the environment by running arbitrary code, permissions may be used to allow
users access only to one or several carefully designed functions or block access to any functions
(default), and the system may remain safe.</p>
<p>Once the API request is accepted by RE Manager, the task is assigned UID (<code class="docutils literal notranslate"><span class="pre">task_uid</span></code>), which
is returned as one of the API response parameters. The task UID allows to track execution
of the task using <a class="reference internal" href="re_manager_api.html#method-task-status"><span class="std std-ref">‘task_status’</span></a> and <a class="reference internal" href="re_manager_api.html#method-task-result"><span class="std std-ref">‘task_result’</span></a> API. Once function
execution is completed, the task contains the return value of the function (in case of success)
and error message and traceback (in case of failure).</p>
<p>Functions may be started as foreground and background tasks. See <a class="reference internal" href="#running-tasks"><span class="std std-ref">Running Tasks</span></a> for details
on running and monitoring tasks.</p>
<p>See the tutorial <a class="reference internal" href="tutorials.html#tutorial-executing-functions"><span class="std std-ref">Executing Functions</span></a>.</p>
</section>
<section id="uploading-scripts">
<span id="id3"></span><h2>Uploading Scripts<a class="headerlink" href="#uploading-scripts" title="Link to this heading">¶</a></h2>
<p>RE Manager provides users with ability to upload and execute Python scripts in the worker namespace.
The <a class="reference internal" href="re_manager_api.html#method-script-upload"><span class="std std-ref">‘script_upload’</span></a> API accepts the script represented as string, which is uploaded
to RE Manager over 0MQ, passed to the worker environment and executed. The script is
executed as a task and <code class="docutils literal notranslate"><span class="pre">task_uid</span></code> returned by the API may be used to monitor the task status
and download results, indicating if the script was completed successfully and containing
the error message and the traceback in case of failure.</p>
<p>The script may contain arbitrary Python code, which is executed in the worker environment. The code
has full access to the worker namespace and may modify, replace or create new objects, including
functions, devices and plans. For example, an uploaded script may contain code for a new plan, which
becomes available in the worker namespace or modified code for an existing plan, which replaces
the plan in the namespace. By default, the lists of existing and allowed plans and devices are updated
after execution of each script. The new plans and devices become immediately available to users
who have appropriate permissions (see <a class="reference internal" href="features_and_config.html#configuring-user-group-permissions"><span class="std std-ref">Configuring User Group Permissions</span></a>).</p>
<p>The variables <code class="docutils literal notranslate"><span class="pre">RE</span></code> and <code class="docutils literal notranslate"><span class="pre">db</span></code> are reserved for instances of Bluesky Run Engine and Data Broker.
By default, the existing <code class="docutils literal notranslate"><span class="pre">RE</span></code> or <code class="docutils literal notranslate"><span class="pre">db</span></code> objects are not replaced in the worker namespace
even if the script contains the respective code (scripts are free to use those objects).
This restriction is implemented to prevent accidental changes to the namespace, which may cause
RE Manager to fail. In order to allow the script to replace <code class="docutils literal notranslate"><span class="pre">RE</span></code> and <code class="docutils literal notranslate"><span class="pre">db</span></code>, call the API
with <code class="docutils literal notranslate"><span class="pre">update_re=True</span></code>. If the uploaded script does not contain new or modified plans or
devices, then there is no need to update the respective lists and the operation may be performed
more efficiently if the <code class="docutils literal notranslate"><span class="pre">update_lists=False</span></code>.</p>
<p>Scripts may be executed as foreground and background tasks. See <a class="reference internal" href="#running-tasks"><span class="std std-ref">Running Tasks</span></a> for details
on running and monitoring tasks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The scripts may contain arbitrary code. Users and developers should carefully consider
what code is executed in the worker namespace and how it affects the state of the worker
environment. For example, a script that executes a plan can be successfully started and
completed as a foreground task, bypassing all mechanisms for queue management, but it is
not advised to do so.</p>
</div>
<p>Uploaded scripts may import modules available on the server. Scripts may also contain
‘local’ imports. For example, if root directory contains a subdirectory <code class="docutils literal notranslate"><span class="pre">mod</span></code> with
a Python file <code class="docutils literal notranslate"><span class="pre">my_module.py</span></code>, the code may be imported as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mod.my_module</span>
</pre></div>
</div>
<p>The root directory is the startup directory (directly passed to <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code> or
determined based on passed or default IPython directory and/or profile name) or the directory
that contains startup script if the server was started with the respective option.
Relative imports (e.g. <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.mod</span> <span class="pre">import</span> <span class="pre">my_module</span></code>) are not supported in the uploaded scripts.</p>
<p>See the tutorial <a class="reference internal" href="tutorials.html#tutorial-uploading-scripts"><span class="std std-ref">Uploading scripts</span></a>.</p>
</section>
<section id="running-tasks">
<span id="id4"></span><h2>Running Tasks<a class="headerlink" href="#running-tasks" title="Link to this heading">¶</a></h2>
<p>Tasks are used for remote monitoring of execution of functions and scripts in RE Worker
namespace. Each task is assigned a UID (<em>task_uid</em>), which is returned by the API starting
the task and can be used to monitor status of the task and load the results after completion.
For example, <a class="reference internal" href="re_manager_api.html#method-function-execute"><span class="std std-ref">‘function_execute’</span></a> API call starting execution of
a function <code class="docutils literal notranslate"><span class="pre">function_sleep</span></code> (defined in the demo startup code) returns</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;item&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;args&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">],</span>
          <span class="s1">&#39;item_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">,</span>
          <span class="s1">&#39;kwargs&#39;</span><span class="p">:</span> <span class="p">{},</span>
          <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;function_sleep&#39;</span><span class="p">,</span>
          <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;qserver-cli&#39;</span><span class="p">,</span>
          <span class="s1">&#39;user_group&#39;</span><span class="p">:</span> <span class="s1">&#39;primary&#39;</span><span class="p">},</span>
<span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>Calling <a class="reference internal" href="re_manager_api.html#method-task-status"><span class="std std-ref">‘task_status’</span></a> and <a class="reference internal" href="re_manager_api.html#method-task-result"><span class="std std-ref">‘task_result’</span></a> with task UID
<code class="docutils literal notranslate"><span class="pre">21ecccbe-df52-4478-a42b-3a94b4f54fcd</span></code> returns information on current status of the task
and the result of task execution after the task is completed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Status returned while the task is still running</span>
<span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;running&#39;</span><span class="p">,</span>
<span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">}</span>

<span class="c1"># Result returned while the task is still running</span>
<span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;result&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;run_in_background&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">,</span>
            <span class="s1">&#39;time_start&#39;</span><span class="p">:</span> <span class="mf">1659709083.4135385</span><span class="p">},</span>
<span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;running&#39;</span><span class="p">,</span>
<span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">}</span>

<span class="c1"># Status returned after the task is completed</span>
<span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;completed&#39;</span><span class="p">,</span>
<span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">}</span>

<span class="c1"># Result returned after the task is completed</span>
<span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="s1">&#39;result&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;return_value&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span>
            <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">,</span>
            <span class="s1">&#39;time_start&#39;</span><span class="p">:</span> <span class="mf">1659709083.4135385</span><span class="p">,</span>
            <span class="s1">&#39;time_stop&#39;</span><span class="p">:</span> <span class="mf">1659709113.4742212</span><span class="p">,</span>
            <span class="s1">&#39;traceback&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">},</span>
<span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;completed&#39;</span><span class="p">,</span>
<span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
<span class="s1">&#39;task_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;21ecccbe-df52-4478-a42b-3a94b4f54fcd&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">return_value</span></code> is the return value of the function (always <code class="docutils literal notranslate"><span class="pre">None</span></code> for a script),
<code class="docutils literal notranslate"><span class="pre">msg</span></code> and <code class="docutils literal notranslate"><span class="pre">traceback</span></code> are the strings representing the error message and full
traceback in case the task fails.</p>
<p>Functions and scripts may be executed as foreground and background tasks. Foreground
tasks are executed in the main thread of RE Worker process. Foreground tasks could be
started only if RE Manager is <em>idle</em>, i.e. no other foreground tasks or plans are
running. As foreground task is started, RE Manager state is changed to <code class="docutils literal notranslate"><span class="pre">'executing_task'</span></code>,
which blocks other foreground tasks or plans from being started. Background tasks are
executed in separate background threads, could be started at any time and do not
block execution of foreground tasks or plans. Any reasonable number of background
tasks could be running at any time. The number of background tasks is returned
as a parameter of RE Manager <a class="reference internal" href="re_manager_api.html#method-status"><span class="std std-ref">‘status’</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">...</span>
<span class="s1">&#39;task_results_uid&#39;</span><span class="p">:</span> <span class="s1">&#39;846b6dd3-d9c2-4a12-bd03-b82580b8f742&#39;</span><span class="p">,</span>
  <span class="o">...</span>
<span class="s1">&#39;worker_background_tasks&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>The parameter <em>‘task_results_uid’</em> is updated each time a new task is started or task
execution is completed. An application waiting for completion of one or more tasks
can wait for the UID to change and then check the status of each task. Considering
that applications are likely to monitor the manager status for other purposes,
monitoring <em>‘task_results_uid’</em> may be more efficient than continuously polling status
of each task.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Task results are stored at the server for a limited time and then deleted. Currently the expiration time
is 2 minutes after completion of the task, but could be parametrized in the future.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Background tasks are executed in background threads. It is responsibility of software or workflow developer
to ensure thread safety. Foreground tasks could be executed in the main thread one at a time and do not
introduce risks associated with thread safety.</p>
</div>
<p>See the tutorials <a class="reference internal" href="tutorials.html#tutorial-executing-functions"><span class="std std-ref">Executing Functions</span></a> and <a class="reference internal" href="tutorials.html#tutorial-uploading-scripts"><span class="std std-ref">Uploading scripts</span></a>.</p>
</section>
<section id="locking-re-manager">
<span id="id5"></span><h2>Locking RE Manager<a class="headerlink" href="#locking-re-manager" title="Link to this heading">¶</a></h2>
<p>Users and client applications can temporarily lock RE Manager. When the manager is locked, users
can access certain groups of API only by pass a <em>lock key</em> with API requests. The <em>lock key</em> is
an arbitrary string selected by the user who locks RE Manager and stays valid until the manager
is unlocked. The key could be shared with other users who need to control the locked manager.
The lock status is stored in Redis. Restarting the manager does not reset the lock. If the manager
is locked, it needs to be unlocked using valid lock key. Optionally, the emergency key may be set
using the environment variable <code class="docutils literal notranslate"><span class="pre">QSERVER_EMERGENCY_LOCK_KEY_FOR_SERVER</span></code>. The emergency key allows
to unlock the manager in case the lock key is lost. It can not be used to control the locked RE Manager.</p>
<p>The <a class="reference internal" href="re_manager_api.html#method-lock"><span class="std std-ref">‘lock’</span></a> API allows to lock the API that control RE Worker environment and/or the queue.
The lock does not affect <em>read-only</em> API, therefore monitoring client applications will continue
working when the manager is locked. The full list of API affected by locking the environment and
the queue can be found in the documentation for <a class="reference internal" href="re_manager_api.html#method-lock"><span class="std std-ref">‘lock’</span></a> API.</p>
<p>The lock is not designed to be used for access control. The typical use case scenarios:</p>
<ul class="simple">
<li><p>A beamline scientist or on-site user locks the environment before entering the hutch to change samples.
This prevents remote users, autonomous agents etc. to open/close the environment, start the queue and
execute plans and tasks. If necessary, the scientist who locked the environment may still perform
those operations using the secret lock key without unlocking the manager. Since the queue is not locked,
the remote users and autonomous agents are still free to edit the queue or add plans to the queue.</p></li>
<li><p>A beamline scientist is performing maintenance or calibration and locks both the environment and
the queue to have exclusive control of the manager.</p></li>
</ul>
<p>API for controlling and monitoring lock status of the manager:</p>
<ul class="simple">
<li><p><a class="reference internal" href="re_manager_api.html#method-lock"><span class="std std-ref">‘lock’</span></a> - lock the environment and/or the queue using a lock key. The API also accepts
the name of the user who locks the manager (required) and a text note to other users (optional).
This information is returned as part of the lock info and included in all relevant error messages.</p></li>
<li><p><a class="reference internal" href="re_manager_api.html#method-unlock"><span class="std std-ref">‘unlock’</span></a> - unlock the manager using the valid lock key (it must be the same key as
for locking the manager) or the emergency lock key (if set). If the key is lost and the emergency
key is not set or unknown, the lock can be cleared using <a class="reference internal" href="cli_tools.html#qserver-clear-lock-cli"><span class="std std-ref">qserver-clear-lock</span></a> CLI tool
and restarting RE Manager application or service.</p></li>
<li><p><a class="reference internal" href="re_manager_api.html#method-lock-info"><span class="std std-ref">‘lock_info’</span></a> - load the manager lock status. The lock status is assigned a UID, which
is updated each time the status is changed. The UID is included in the manager status (<a class="reference internal" href="re_manager_api.html#method-status"><span class="std std-ref">‘status’</span></a> API),
which simplifies monitoring of the lock status. The manager status also contains <em>‘lock’</em> parameter,
which indicates if the environment and/or the queue are currently locked.</p></li>
</ul>
<p>The operations of locking and unlocking RE Manager using CLI tool could be found in the tutorial
<a class="reference internal" href="tutorials.html#tutorial-locking-re-manager"><span class="std std-ref">Locking RE Manager</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="re_manager_api.html#method-lock"><span class="std std-ref">‘lock’</span></a> API controls access to other API, not internal operation of the server.
For example, if the server is executing the queue, the queue will continue running after
the manager is locked until it runs out of plans or stopped.</p>
</div>
</section>
<section id="queue-autostart-mode">
<span id="id6"></span><h2>Queue Autostart Mode<a class="headerlink" href="#queue-autostart-mode" title="Link to this heading">¶</a></h2>
<p>RE Manager supports queue autostart mode. In the autostart mode, the manager automatically
starts execution of the queue whenever the queue is not empty and the manager and the worker
are in the correct state. For example, if the autostart mode is enabled at the time when
the queue is empty, adding a queue item will automatically start the queue execution.
Once the queue runs out of items, the manager is switched to IDLE state, but the queue
is automatically restarted once more items are added to the queue. If the manager is busy
executing another task (a script or a function) when the plan is added, the queue is
restarted once the current task is completed.</p>
<p>The autostart is enabled by calling <a class="reference internal" href="re_manager_api.html#method-queue-autostart"><span class="std std-ref">‘queue_autostart’</span></a> API with <em>enable=True</em> and
disabled using the same API with <em>enable=False</em>. The mode can be enabled at any time,
even when the queue can not be started (e.g. the environment is closed). The manager
will automatically monitor the state start the queue when possible (e.g. once the environment
is opened). The autostart is automatically disabled once the queue is stopped by the user
(by inserting <em>‘queue_stop’</em> queue instruction or by calling <a class="reference internal" href="re_manager_api.html#method-queue-stop"><span class="std std-ref">‘queue_stop’</span></a> API)
or a plan is stopped/halted/aborted or failed (unless <em>ignore_failures</em> queue mode is enabled).</p>
<p>The autostart may be also enabled and disabled using CLI interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qserver</span> <span class="n">queue</span> <span class="n">autostart</span> <span class="n">enable</span>
<span class="n">qserver</span> <span class="n">queue</span> <span class="n">autostart</span> <span class="n">disable</span>
</pre></div>
</div>
<p>See documentation on <a class="reference internal" href="re_manager_api.html#method-queue-autostart"><span class="std std-ref">‘queue_autostart’</span></a> API for more details.</p>
</section>
<section id="running-re-worker-with-ipython-kernel">
<span id="worker-ipython-kernel"></span><h2>Running RE Worker with IPython Kernel<a class="headerlink" href="#running-re-worker-with-ipython-kernel" title="Link to this heading">¶</a></h2>
<p>Queue Server can be configured to run worker execution environment in IPython kernel.
The kernel is created in the worker process and used to execute plans, functions and script.
In IPython mode, the worker can load startup code and scripts with IPython-specific
features, such as magics, <code class="docutils literal notranslate"><span class="pre">user_ns</span></code>, etc. Users may also connect to the kernel directly
bypassing RE Manager using Jupyter Console.</p>
<section id="starting-re-manager-in-ipython-mode">
<h3>Starting RE Manager in IPython Mode<a class="headerlink" href="#starting-re-manager-in-ipython-mode" title="Link to this heading">¶</a></h3>
<p>RE Manager is configured to use IPython kernel by passing <code class="docutils literal notranslate"><span class="pre">--use-ipython-kernel=ON</span></code> parameter
to <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code>, setting config parameter <code class="docutils literal notranslate"><span class="pre">worker/use_ipython_kernel:</span> <span class="pre">True</span></code> or
environment variable <code class="docutils literal notranslate"><span class="pre">QSERVER_USE_IPYTHON_KERNEL=True</span></code>.</p>
</section>
<section id="specifying-ipython-kernel-ip-address">
<h3>Specifying IPython Kernel IP Address<a class="headerlink" href="#specifying-ipython-kernel-ip-address" title="Link to this heading">¶</a></h3>
<p>The IPython kernel IP address is set using <code class="docutils literal notranslate"><span class="pre">--ipython-kernel-ip</span></code> parameter of
<code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code>, setting <code class="docutils literal notranslate"><span class="pre">QSERVER_IPYTHON_KERNEL_IP</span></code> environment variable or
or by setting config parameter <code class="docutils literal notranslate"><span class="pre">worker/ipython_kernel_ip</span></code>. The parameter values
are <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code> (default), <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> or a string represting valid network
IP address of the host running the kernel, such as <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> or <code class="docutils literal notranslate"><span class="pre">192.168.50.49</span></code>.
If the IP address is <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code>, the kernel does not accept
connections from other hosts. If the parameter is set to <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, Queue Server attempts
to automatically determine network IP address of the host and passes it to the kernel.
If the network IP address is determined correctly, the kernel will accept connections
from other hosts. If automatic mode fails, the correct IP address may be explicitly passed to
the server. The IP address passed to the kernel is returned as part of connection info,
which is used by client applications to connect to the kernel
(see <a class="reference internal" href="re_manager_api.html#method-config-get"><span class="std std-ref">‘config_get’</span></a> API).</p>
</section>
<section id="specifying-location-of-startup-code">
<h3>Specifying Location of Startup Code<a class="headerlink" href="#specifying-location-of-startup-code" title="Link to this heading">¶</a></h3>
<p>In this mode, RE Worker starts embedded IPython kernel, loading the startup code, IPython
configuration and IPython history during kernel initialization. The location of the
startup code is determined based on <code class="docutils literal notranslate"><span class="pre">--startup-profile</span></code>, <code class="docutils literal notranslate"><span class="pre">--startup-module</span></code>,
<code class="docutils literal notranslate"><span class="pre">--startup-script</span></code> and <code class="docutils literal notranslate"><span class="pre">--startup-dir</span></code> parameters of <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code>
(<code class="docutils literal notranslate"><span class="pre">startup/startup_profile</span></code>, <code class="docutils literal notranslate"><span class="pre">startup/startup_module</span></code>, <code class="docutils literal notranslate"><span class="pre">startup/startup_script</span></code> and
<code class="docutils literal notranslate"><span class="pre">startup/startup_dir</span></code> parameters in the config file). The kernel looks for the startup
code in <code class="docutils literal notranslate"><span class="pre">&lt;ipythondir&gt;/profile_&lt;profile_name&gt;/startup</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;ipythondir&gt;</span></code> is
the value of the environment variable <code class="docutils literal notranslate"><span class="pre">IPYTHONDIR</span></code>, which determines the location of
IPython profiles (default location is <code class="docutils literal notranslate"><span class="pre">~/.ipython</span></code>) and <code class="docutils literal notranslate"><span class="pre">profile_name</span></code> is
the name passed using <code class="docutils literal notranslate"><span class="pre">--startup-profile</span></code> parameter. The location of IPython profiles
may also be specified using <code class="docutils literal notranslate"><span class="pre">--ipython-dir</span></code> parameter, which overrides <code class="docutils literal notranslate"><span class="pre">IPYTHONDIR</span></code>
environment variable. Alternatively, the location of startup profile may be specified
using <code class="docutils literal notranslate"><span class="pre">--startup-dir</span></code> parameter. If RE Manager is configured to use IPython kernel,
the startup directory must match the standard pattern (<code class="docutils literal notranslate"><span class="pre">&lt;ipythondir&gt;/profile_&lt;profile_name&gt;/startup</span></code>),
so that it could be successfully parsed to extract the profile name and IPython directory.</p>
<p>In addition to the startup code in IPython profile, the IPython kernel may also load
a startup script or a startup module if path to a script or a path to a module is specified.
This behavior is different from the behavior of the Python-based worker, which does not attempt
to load the profile startup files if a path to a script or module name is specified.
If loading of startup code is undesirable, create a profile with empty <code class="docutils literal notranslate"><span class="pre">startup</span></code> directory
and pass the profile name to RE Manager. If <code class="docutils literal notranslate"><span class="pre">--startup-script</span></code> or <code class="docutils literal notranslate"><span class="pre">--startup-module</span></code> is specified,
but no profile name is passed, then default IPython profile (<code class="docutils literal notranslate"><span class="pre">$IPYTHONDIR/profile_default</span></code>) is loaded.</p>
</section>
<section id="setting-matplotlib-backend">
<h3>Setting Matplotlib Backend<a class="headerlink" href="#setting-matplotlib-backend" title="Link to this heading">¶</a></h3>
<p>If RE Manager is running on the local machine and IPython mode is enabled, the in-process live
plotting may be performed directly from the worker environment. This feature may be convenient
for users, who wish to keep the existing interactive IPython-based workflows, but may
want to mix REPL interactions with API control of the environment (e.g. for GUI or autonomous
control). In order to enable plotting, the appropriate Matplotlib backend must be set
using <code class="docutils literal notranslate"><span class="pre">--ipython-matplotlib</span></code> parameter of <code class="docutils literal notranslate"><span class="pre">start-re-manager</span></code> or <code class="docutils literal notranslate"><span class="pre">worker/ipython_matplotlib</span></code>
config parameter. The parameter is passed directly to IPython kernel and accepts the same
set of values as the <code class="docutils literal notranslate"><span class="pre">--matplotlib</span></code> parameter of <code class="docutils literal notranslate"><span class="pre">ipython</span></code>. The backend is set to <code class="docutils literal notranslate"><span class="pre">agg</span></code>
by default, which disables plotting and should be used when running RE Manager on a remote server.
Select another appriate backend (e.g. <code class="docutils literal notranslate"><span class="pre">qt5</span></code>) to enable plotting.</p>
</section>
<section id="monitoring-the-state-of-ipython-kernel">
<h3>Monitoring the State of IPython Kernel<a class="headerlink" href="#monitoring-the-state-of-ipython-kernel" title="Link to this heading">¶</a></h3>
<p>The state of the running IPython kernel can be monitored by checking <code class="docutils literal notranslate"><span class="pre">ip_kernel_state</span></code>
parameter of RE Manager status (see <a class="reference internal" href="re_manager_api.html#method-status"><span class="std std-ref">‘status’</span></a> API). The status parameter
<code class="docutils literal notranslate"><span class="pre">ip_kernel_captured</span></code> indicates if the running kernel is ‘captured’ by RE Manager.
The parameter is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the kernel is running foreground task started by
the manager and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. External clients can not interact with the kernel
while it is ‘captured’ by the manager. Both parameters are <em>None</em> if the environment is
not running or the worker is not using IPython kernel.</p>
</section>
<section id="downloading-kernel-connection-info">
<h3>Downloading Kernel Connection Info<a class="headerlink" href="#downloading-kernel-connection-info" title="Link to this heading">¶</a></h3>
<p>Connection info for a running IPython kernel can be downloaded at any time by sending
<a class="reference internal" href="re_manager_api.html#method-config-get"><span class="std std-ref">‘config_get’</span></a> API request to RE Manager (CLI command: <code class="docutils literal notranslate"><span class="pre">qserver</span> <span class="pre">config</span></code>).
The connection info (<code class="docutils literal notranslate"><span class="pre">ip_connect_info</span></code> key) is a dictionary, which contains network
IP address of the host running the kernel, numbers of 0MQ ports, etc. The connection
info dictionary is empty if the kernel is not running for any reason. Since the old
kernel is destroyed each time the environment is closed and a new kernel is created each
time the environment is opened, the updated connection info must be downloaded again
for the new environment. The <code class="docutils literal notranslate"><span class="pre">qserver-console</span></code> CLI tool automatically loads
the connection info from RE Manager and starts Jupyter Console connected to the kernel.</p>
</section>
<section id="connecting-to-running-ipython-kernel-using-jupyter-console">
<h3>Connecting to Running IPython Kernel Using Jupyter Console<a class="headerlink" href="#connecting-to-running-ipython-kernel-using-jupyter-console" title="Link to this heading">¶</a></h3>
<p>Once IPython kernel is running in the worker process (RE Manager is started with
enabled IPython option and the environment is open), users may connect to it directly
using Jupyter Console by running <a class="reference internal" href="cli_tools.html#qserver-console-cli"><span class="std std-ref">qserver-console</span></a> CLI tool, which loads connection
info from RE Manager and passes it to Jupyter Console application.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the kernel is running any foreground tasks (plans, functions, scripts) started by
RE Manager, Jupyter Console will remain unresponsive until the task is complete
and the ‘captured’ kernel is freed.</p>
</div>
<p>Jupyter Console works similarly to IPython terminal, except that closing the console
does not interrupt tasks started from the console. For example, a plan started manually
from the console will continue running after console is closed. The plan execution will not
be managed by RE Manager, but the plan output will be included in RE Manager console output
and streamed to all subscribed consumers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">Ctrl-D</span></code> to close the Jupyter Console. Typing <code class="docutils literal notranslate"><span class="pre">quit</span></code> or <code class="docutils literal notranslate"><span class="pre">exit</span></code> in Jupyter
console will close the kernel and cause the worker environment to close.</p>
</div>
<p>See documentation on <a class="reference internal" href="cli_tools.html#qserver-console-cli"><span class="std std-ref">qserver-console</span></a> for more information.</p>
</section>
<section id="updating-the-worker-environment-cache">
<h3>Updating the Worker Environment Cache<a class="headerlink" href="#updating-the-worker-environment-cache" title="Link to this heading">¶</a></h3>
<p>Users connected directly to the IPython kernel via Jupyter Console may change the contents
of the worker namespace, including operations such as adding, deleting or modifying plans
and devices in the namespace. To make RE Manager aware of the changes and make the updated
plans and devices reflected in the lists of existing/allowed plans and devices call the
<a class="reference internal" href="re_manager_api.html#method-environment-update"><span class="std std-ref">‘environment_update’</span></a> API.</p>
</section>
<section id="interrupting-the-ipython-kernel">
<h3>Interrupting the IPython Kernel<a class="headerlink" href="#interrupting-the-ipython-kernel" title="Link to this heading">¶</a></h3>
<p>The IPython kernel can be interrupted (equivalent to <code class="docutils literal notranslate"><span class="pre">Ctrl-C</span></code>) using <a class="reference internal" href="re_manager_api.html#method-kernel-interrupt"><span class="std std-ref">‘kernel_interrupt’</span></a>
API. By default, the API fails if called while the RE Manager is executing a plan or a foreground task
(a script or a function) started via the manager. The API parameters <code class="docutils literal notranslate"><span class="pre">interrupt_plan</span></code> and
<code class="docutils literal notranslate"><span class="pre">interrupt_task</span></code> of the API can be used to override the default behavior.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Though a plan can be paused by sending the interrupt once (deferred pause) or twice (immediate pause),
using <a class="reference internal" href="re_manager_api.html#method-re-pause"><span class="std std-ref">‘re_pause’</span></a> API is a preferable way to pause a plan started via RE Manager or directly
using Jupyter Console.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction_for_users.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="features_and_config.html" class="btn btn-neutral float-right" title="Features and Configuration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, Brookhaven National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>