<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Run Engine Manager API &mdash; bluesky-queueserver 0.0.18.post76+g879a108 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="bluesky_queueserver.ZMQCommSendAsync" href="generated/bluesky_queueserver.ZMQCommSendAsync.html" />
    <link rel="prev" title="bluesky_queueserver.format_text_descriptions" href="generated/bluesky_queueserver.format_text_descriptions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            bluesky-queueserver
          </a>
              <div class="version">
                0.0.18.post76+g879a108
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/bluesky/bluesky-queueserver">Source Code on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_for_users.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_queue_server.html">Using the Queue Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="features_and_config.html">Features and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="startup_code.html">Organizing Bluesky Startup Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipython.html">Using IPython Startup Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="item_validation.html">Validation of Queue Items</a></li>
<li class="toctree-l1"><a class="reference internal" href="plan_annotation.html">Annotating Bluesky Plans</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli_tools.html">Command-Line Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="manager_config.html">RE Manager Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="qserver_quick_ref.html"><em>qserver</em> : Quick Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Application Developer's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="interacting_with_qs.html">Interacting with Queue Server</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Run Engine Manager API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#asyncio-based-api-for-controlling-re-manager">Asyncio-Based API for Controlling RE Manager</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.html">bluesky_queueserver.ZMQCommSendAsync</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.send_message.html">bluesky_queueserver.ZMQCommSendAsync.send_message</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.close.html">bluesky_queueserver.ZMQCommSendAsync.close</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#thread-based-api-for-controlling-re-manager">Thread-Based API for Controlling RE Manager</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.html">bluesky_queueserver.ZMQCommSendThreads</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.send_message.html">bluesky_queueserver.ZMQCommSendThreads.send_message</a></li>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.close.html">bluesky_queueserver.ZMQCommSendThreads.close</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#supported-methods-for-zmq-communication-api">Supported Methods For ZMQ Communication API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#brief-reference">Brief Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#detailed-reference">Detailed Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ping"><strong>‘ping’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#status"><strong>‘status’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#plans-allowed"><strong>‘plans_allowed’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#devices-allowed"><strong>‘devices_allowed’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#plans-existing"><strong>‘plans_existing’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#devices-existing"><strong>‘devices_existing’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#permissions-reload"><strong>‘permissions_reload’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#permissions-get"><strong>‘permissions_get’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#permissions-set"><strong>‘permissions_set’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#history-get"><strong>‘history_get’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#history-clear"><strong>‘history_clear’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-open"><strong>‘environment_open’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-close"><strong>‘environment_close’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-destroy"><strong>‘environment_destroy’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-mode-set"><strong>‘queue_mode_set’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-get"><strong>‘queue_get’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-add"><strong>‘queue_item_add’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-add-batch"><strong>‘queue_item_add_batch’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-update"><strong>‘queue_item_update’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-get"><strong>‘queue_item_get’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-remove"><strong>‘queue_item_remove’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-remove-batch"><strong>‘queue_item_remove_batch’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-move"><strong>‘queue_item_move’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-move-batch"><strong>‘queue_item_move_batch’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-item-execute"><strong>‘queue_item_execute’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-clear"><strong>‘queue_clear’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-start"><strong>‘queue_start’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-stop"><strong>‘queue_stop’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-stop-cancel"><strong>‘queue_stop_cancel’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#re-pause"><strong>‘re_pause’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#re-resume-re-stop-re-abort-re-halt"><strong>‘re_resume’, ‘re_stop’, ‘re_abort’, ‘re_halt’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#re-runs"><strong>‘re_runs’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#script-upload"><strong>‘script_upload’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-execute"><strong>‘function_execute’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-status"><strong>‘task_status’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-result"><strong>‘task_result’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lock"><strong>‘lock’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#lock-info"><strong>‘lock_info’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#unlock"><strong>‘unlock’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#manager-stop"><strong>‘manager_stop’</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#manager-kill"><strong>‘manager_kill’</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Related Projects</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-queueserver-api">Bluesky Queue Server API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-httpserver">Bluesky HTTP Server</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky-widgets">Bluesky Widgets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/bluesky">Bluesky</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/ophyd">Ophyd</a></li>
<li class="toctree-l1"><a class="reference external" href="https://blueskyproject.io/databroker">Data Broker</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bluesky-queueserver</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Run Engine Manager API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/re_manager_api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="run-engine-manager-api">
<span id="id1"></span><h1>Run Engine Manager API<a class="headerlink" href="#run-engine-manager-api" title="Permalink to this heading">¶</a></h1>
<section id="asyncio-based-api-for-controlling-re-manager">
<h2>Asyncio-Based API for Controlling RE Manager<a class="headerlink" href="#asyncio-based-api-for-controlling-re-manager" title="Permalink to this heading">¶</a></h2>
<p>Asyncio-based API is designed for use in applications that employ <cite>asyncio</cite> event loop.
For example, HTTP server module is using asyncio-based API for communication with RE Manager.
Communication is performed by instantiating <cite>ZMQCommSendAsync</cite> class and awaiting
<cite>ZMQCommSendAsync.send_message()</cite> function, which accepts the method name and parameters
as arguments and returns the response message.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.html#bluesky_queueserver.ZMQCommSendAsync" title="bluesky_queueserver.ZMQCommSendAsync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendAsync</span></code></a></p></td>
<td><p>API for communication with RE Manager via ZMQ.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.send_message.html#bluesky_queueserver.ZMQCommSendAsync.send_message" title="bluesky_queueserver.ZMQCommSendAsync.send_message"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendAsync.send_message</span></code></a></p></td>
<td><p>Send message to ZMQ server and wait for the response.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendAsync.close.html#bluesky_queueserver.ZMQCommSendAsync.close" title="bluesky_queueserver.ZMQCommSendAsync.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendAsync.close</span></code></a></p></td>
<td><p>Close ZMQ socket.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="thread-based-api-for-controlling-re-manager">
<h2>Thread-Based API for Controlling RE Manager<a class="headerlink" href="#thread-based-api-for-controlling-re-manager" title="Permalink to this heading">¶</a></h2>
<p>Thread-based API is designed for use in applications that are not based on <cite>asyncio</cite> event loop,
such as PyQT applications or simple python scripts. Communication with RE Manager is performed
by instantiating <cite>ZMQCommSendThreads</cite> class and calling <cite>ZMQCommSendThreads.send_message()</cite>
function, which accepts the method name and parameters. The <cite>send_message()</cite> function may be
called in blocking and non-blocking mode. In blocking mode, the function returns the response
message. In non-blocking mode the function exits once ZMQ request is send to RE Manager and
passes the response message to user-defined callback function once the response is received.
The reference to the callback function is passed to <cite>send_message()</cite> function as one of the
arguments.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.html#bluesky_queueserver.ZMQCommSendThreads" title="bluesky_queueserver.ZMQCommSendThreads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendThreads</span></code></a></p></td>
<td><p>Thread-based API for communication with RE Manager via ZMQ.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.send_message.html#bluesky_queueserver.ZMQCommSendThreads.send_message" title="bluesky_queueserver.ZMQCommSendThreads.send_message"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendThreads.send_message</span></code></a></p></td>
<td><p>Send message to ZMQ server and wait for the response.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.ZMQCommSendThreads.close.html#bluesky_queueserver.ZMQCommSendThreads.close" title="bluesky_queueserver.ZMQCommSendThreads.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ZMQCommSendThreads.close</span></code></a></p></td>
<td><p>Close ZMQ socket.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="supported-methods-for-zmq-communication-api">
<span id="supported-methods-for-0mq-api"></span><h2>Supported Methods For ZMQ Communication API<a class="headerlink" href="#supported-methods-for-zmq-communication-api" title="Permalink to this heading">¶</a></h2>
<section id="brief-reference">
<h3>Brief Reference<a class="headerlink" href="#brief-reference" title="Permalink to this heading">¶</a></h3>
<p>The following reference describes the methods used for controlling RE Manager. For each
method, the documentation contains the description of outgoing and returned parameters.
Method name and the dictionary of method parameters are passed as arguments to
<cite>send_message()</cite> API function.</p>
<p>The result of the request processing is returned
as a dictionary of the returned parameters by <cite>send_message()</cite> function or passed as
an argument of the callback. In case of communication error, <cite>send_message</cite> function may
raise the exception (default) or return the error message. If reference to a callback function
is passed to <cite>send_message</cite> (in thread-based API), the communication error message will be
passed as <cite>msg_err</cite> parameter of the callback function</p>
<p>Get status information from RE Manager:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-ping"><span class="std std-ref">‘ping’</span></a></p></li>
<li><p><a class="reference internal" href="#method-status"><span class="std std-ref">‘status’</span></a></p></li>
</ul>
<p>Existing and allowed plans and devices:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-plans-allowed"><span class="std std-ref">‘plans_allowed’</span></a></p></li>
<li><p><a class="reference internal" href="#method-devices-allowed"><span class="std std-ref">‘devices_allowed’</span></a></p></li>
<li><p><a class="reference internal" href="#method-plans-existing"><span class="std std-ref">‘plans_existing’</span></a></p></li>
<li><p><a class="reference internal" href="#method-devices-existing"><span class="std std-ref">‘devices_existing’</span></a></p></li>
<li><p><a class="reference internal" href="#method-permissions-reload"><span class="std std-ref">‘permissions_reload’</span></a></p></li>
<li><p><a class="reference internal" href="#method-permissions-get"><span class="std std-ref">‘permissions_get’</span></a></p></li>
<li><p><a class="reference internal" href="#method-permissions-set"><span class="std std-ref">‘permissions_set’</span></a></p></li>
</ul>
<p>History of executed plans:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-history-get"><span class="std std-ref">‘history_get’</span></a></p></li>
<li><p><a class="reference internal" href="#method-history-clear"><span class="std std-ref">‘history_clear’</span></a></p></li>
</ul>
<p>Open and close RE Worker environment:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-environment-open"><span class="std std-ref">‘environment_open’</span></a></p></li>
<li><p><a class="reference internal" href="#method-environment-close"><span class="std std-ref">‘environment_close’</span></a></p></li>
<li><p><a class="reference internal" href="#method-environment-destroy"><span class="std std-ref">‘environment_destroy’</span></a></p></li>
</ul>
<p>Operations with the plan queue:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-queue-mode-set"><span class="std std-ref">‘queue_mode_set’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-get"><span class="std std-ref">‘queue_get’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-add"><span class="std std-ref">‘queue_item_add’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-add-batch"><span class="std std-ref">‘queue_item_add_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-update"><span class="std std-ref">‘queue_item_update’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-get"><span class="std std-ref">‘queue_item_get’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-remove"><span class="std std-ref">‘queue_item_remove’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-remove-batch"><span class="std std-ref">‘queue_item_remove_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-move"><span class="std std-ref">‘queue_item_move’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-move-batch"><span class="std std-ref">‘queue_item_move_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-execute"><span class="std std-ref">‘queue_item_execute’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-clear"><span class="std std-ref">‘queue_clear’</span></a></p></li>
</ul>
<p>Start and stop execution of the plan queue:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-queue-start"><span class="std std-ref">‘queue_start’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-stop"><span class="std std-ref">‘queue_stop’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-stop-cancel"><span class="std std-ref">‘queue_stop_cancel’</span></a></p></li>
</ul>
<p>Send commands to Bluesky Run Engine:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-re-pause"><span class="std std-ref">‘re_pause’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_resume’, ‘re_stop’, ‘re_abort’, ‘re_halt’</span></a></p></li>
</ul>
<p>Monitor the list of active runs:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-re-runs"><span class="std std-ref">‘re_runs’</span></a></p></li>
</ul>
<p>Run tasks in RE Worker namespace:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-script-upload"><span class="std std-ref">‘script_upload’</span></a></p></li>
<li><p><a class="reference internal" href="#method-function-execute"><span class="std std-ref">‘function_execute’</span></a></p></li>
<li><p><a class="reference internal" href="#method-task-status"><span class="std std-ref">‘task_status’</span></a></p></li>
<li><p><a class="reference internal" href="#method-task-result"><span class="std std-ref">‘task_result’</span></a></p></li>
</ul>
<p>Lock/unlock RE Manager:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a></p></li>
<li><p><a class="reference internal" href="#method-lock-info"><span class="std std-ref">‘lock_info’</span></a></p></li>
<li><p><a class="reference internal" href="#method-unlock"><span class="std std-ref">‘unlock’</span></a></p></li>
</ul>
<p>Stopping RE Manager (mostly used in testing):</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-manager-stop"><span class="std std-ref">‘manager_stop’</span></a></p></li>
<li><p><a class="reference internal" href="#method-manager-kill"><span class="std std-ref">‘manager_kill’</span></a></p></li>
</ul>
</section>
<section id="detailed-reference">
<h3>Detailed Reference<a class="headerlink" href="#detailed-reference" title="Permalink to this heading">¶</a></h3>
<section id="ping">
<span id="method-ping"></span><h4><strong>‘ping’</strong><a class="headerlink" href="#ping" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘ping’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Causes RE Manager to send some predefined response. Currently ‘ping’ request is
equivalent to ‘status’ request. The functionality may be changed in the future.
Use ‘status’ method to request status information from RE Manager.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><p>See ‘status’ method for information on returned data.</p></td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="status">
<span id="method-status"></span><h4><strong>‘status’</strong><a class="headerlink" href="#status" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘status’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns status of RE Manager.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>application name and version, e.g. ‘RE Manager v0.0.10’</p>
</dd>
<dt><strong>items_in_queue</strong>: <em>int</em></dt><dd><p>the number of items in the plan queue</p>
</dd>
<dt><strong>items_in_history</strong>: <em>int</em></dt><dd><p>the number of items in the plan history</p>
</dd>
<dt><strong>running_item_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>item UID of the currently running plan or <em>None</em> if no plan is currently running.
Monitor <strong>plan_queue_uid</strong> to detect updates of the queue and running item data.</p>
</dd>
<dt><strong>plan_queue_uid</strong>: <em>str</em></dt><dd><p>plan queue UID, which is updated each time the contents of the queue is changed.
Monitor this parameter to determine when the queue or running item data was
updated at the server (see <strong>queue_get</strong> API).</p>
</dd>
<dt><strong>plan_history_uid</strong>: <em>str</em></dt><dd><p>plan history UID, which is updated each time the contents of the history is changed.
Monitor this parameter to determine when the history data should be downloaded.</p>
</dd>
<dt><strong>task_results_uid</strong>: <em>str</em></dt><dd><p>UID of the dictionary of task results. UID is updated each time results of a new
completed tasks are added to the dictionary. Check the status of the pending tasks
(see <em>task_result</em> API) once UID is changed.</p>
</dd>
<dt><strong>plans_allowed_uid</strong>: <em>str</em></dt><dd><p>UID for the list of allowed plans. UID is updated each time the contents of
the list is changed. Monitor the UID to detect changes in the list of allowed
plans and download the list from the server only when it is updated.</p>
</dd>
<dt><strong>devices_allowed_uid</strong>: <em>str</em></dt><dd><p>UID for the list of allowed devices. Similar to <strong>plans_allowed_uid</strong>.</p>
</dd>
<dt><strong>plans_existing_uid</strong>: <em>str</em></dt><dd><p>UID for the list of existing plans in RE Worker namespace. Similar to
<strong>plans_allowed_uid</strong>.</p>
</dd>
<dt><strong>devices_existing_uid</strong>: <em>str</em></dt><dd><p>UID for the list of existing devices in RE Worker namespace. Similar to
<strong>plans_allowed_uid</strong>.</p>
</dd>
<dt><strong>‘run_list_uid’</strong> - UID of the list of the active runs. Monitor this UID and</dt><dd><p>load the updated list of active runs once the UID is changed.</p>
</dd>
<dt><strong>manager_state</strong>: <em>str</em></dt><dd><p>state of RE Manager. Supported states:</p>
<ul class="simple">
<li><p><strong>‘initializing’</strong> - RE Manager is initializing (the RE Manager is starting
or restarting)</p></li>
<li><p><strong>‘idle’</strong> - RE Manager is idle and ready to execute requests. Many requests will fail
if RE Manager is not in the idle state.</p></li>
<li><p><strong>‘paused’</strong> - a plan was paused and Run Engine is in the paused state.
The plan needs to be resumed, stopped, halted or aborted.</p></li>
<li><p><strong>‘creating_environment’</strong> - RE Worker environment is in the process of being created.</p></li>
<li><p><strong>‘starting_queue’</strong> - preparing to execute the queue.</p></li>
<li><p><strong>‘executing_queue’</strong> - queue is being executed.</p></li>
<li><p><strong>‘executing_task’</strong> - foreground task (function or script) is being executed.</p></li>
<li><p><strong>‘closing_environment’</strong> - RE Worker environment is in the process of being
closed (safe).</p></li>
<li><p><strong>‘destroying_environment’</strong> - RE Worker environment is in the process of being
destroyed (emergency).</p></li>
</ul>
</dd>
<dt><strong>re_state</strong>: <em>str</em> or <em>None</em></dt><dd><p>current state of Bluesky Run Engine (see Blue Sky documentation) or <em>None</em> if
RE Worker environment does not exist (or closed).</p>
</dd>
<dt><strong>worker_environment_state</strong>: <em>str</em></dt><dd><p>current state of the worker environment. Supported states: <em>‘initializing’</em>,
<em>‘idle’</em>, <em>‘executing_plan’</em>, <em>‘executing_task’</em>, <em>‘closing’</em> and <em>‘closed’</em>.
Running background tasks does not influence the state (<em>‘executing_task’</em> is
not set). The environment state is different from Run Engine state (<em>re_state</em>),
e.g. the environment is considered <em>idle</em> when the current plan is paused.</p>
</dd>
<dt><strong>worker_background_tasks</strong>: <em>int</em></dt><dd><p>the number of background tasks, which are currently running in the worker environment.
Excessive or growing number of background task may indicated serious issue with
the environment. The parameter represents the number of background tasks executed
in separate threads, such as tasks started by API requests <em>script_upload</em> and
<em>function_execute</em> with <em>run_in_background=True</em>. Foreground tasks that block
execution of plans and other tasks are not counted.</p>
</dd>
<dt><strong>plan_queue_mode</strong>: <em>dict</em></dt><dd><p>the dictionary of parameters that determine queue execution mode. The key/value pairs
in the dictionary represent parameter names and values. Supported parameters:
<em>‘loop’</em> (<em>boolean</em>) - indicates if the LOOP mode is enabled.</p>
</dd>
<dt><strong>queue_stop_pending</strong>: <em>boolean</em></dt><dd><p>indicates if the request to stop the queue after completion of the current plan is
pending.</p>
</dd>
<dt><strong>pause_pending</strong>: <em>boolean</em></dt><dd><p>indicates if the request to pause the currently running plan was send to Run Engine
(see <strong>re_pause</strong> method), but the plan is not stopped yet. It may take considerable
time for deferred pause to be processed.</p>
</dd>
<dt><strong>worker_environment_exists</strong>: <em>boolean</em></dt><dd><p>indicates if RE Worker environment was created and plans could be executed.</p>
</dd>
<dt><strong>lock_info_uid</strong>: <em>str</em></dt><dd><p>UID of <strong>lock_info</strong> (see <strong>lock</strong> and <strong>lock_info</strong> API). Reload <em>lock_info</em> using
<strong>lock_info</strong> API when the UID is changed.</p>
</dd>
<dt><strong>lock</strong>: <em>dict</em></dt><dd><p>The dictionary contains information on current status of the lock:</p>
<ul class="simple">
<li><p><strong>environment</strong> (<em>boolean</em>) - indicates if the RE Worker environment is locked.
See the <strong>lock</strong> API for details.</p></li>
<li><p><strong>queue</strong> (<em>boolean</em>) - indicates if the queue is locked. See the <strong>lock</strong> API
for details.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="plans-allowed">
<span id="method-plans-allowed"></span><h4><strong>‘plans_allowed’</strong><a class="headerlink" href="#plans-allowed" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘plans_allowed’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns a dictionary that contains information on the allowed plans for a given user
group. Monitor <em>‘plans_allowed_uid’</em> status field and download the list from the
server only when the UID is changed.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>plans_allowed</strong>: <em>dict</em></dt><dd><p>the dictionary that contains information on the allowed plans.
Dictionary keys are plan names.</p>
</dd>
<dt><strong>plans_allowed_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>UID of the list of allowed plans, <em>None</em> if the request fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="devices-allowed">
<span id="method-devices-allowed"></span><h4><strong>‘devices_allowed’</strong><a class="headerlink" href="#devices-allowed" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘devices_allowed’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns a dictionary that contains information on the allowed devices for a given user
group. Monitor <em>‘devices_allowed_uid’</em> status field and download the list from the
server only when the UID is changed.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>devices_allowed</strong>: <em>dict</em></dt><dd><p>the dictionary that contains information on the allowed devices.
Dictionary keys are device names.</p>
</dd>
<dt><strong>devices_allowed_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>UID of the list of allowed devices, <em>None</em> if the request fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="plans-existing">
<span id="method-plans-existing"></span><h4><strong>‘plans_existing’</strong><a class="headerlink" href="#plans-existing" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘plans_existing’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns a dictionary that contains information on existing plans in the RE Worker
namespace. Monitor <em>‘plans_existing_uid’</em> status field and download the list from the
server only when the UID is changed.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>plans_existing</strong>: <em>dict</em></dt><dd><p>the dictionary that contains information on the existing plans.
Dictionary keys are plan names.</p>
</dd>
<dt><strong>plans_existing_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>UID of the list of existing plans, <em>None</em> if the request fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="devices-existing">
<span id="method-devices-existing"></span><h4><strong>‘devices_existing’</strong><a class="headerlink" href="#devices-existing" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘devices_existing’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns a dictionary that contains information on the existing devices in RE Worker
namespace. Monitor <em>‘devices_existing_uid’</em> status field and download the list from the
server only when the UID is changed.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>devices_existing</strong>: <em>dict</em></dt><dd><p>the dictionary that contains information on the existing devices.
Dictionary keys are device names.</p>
</dd>
<dt><strong>devices_existing_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>UID of the list of existing devices, <em>None</em> if the request fails</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="permissions-reload">
<span id="method-permissions-reload"></span><h4><strong>‘permissions_reload’</strong><a class="headerlink" href="#permissions-reload" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘permissions_reload’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Reload user group permissions from the default location or the location set using
command line parameters and generate lists of allowed plans and devices based on
the lists of existing plans and devices. By default, the method will use current lists
of existing plans and devices stored in memory. Optionally the method can reload the
lists from the disk file (see <em>restore_plans_devices</em> parameter). The method always
updates UIDs of the lists of allowed plans and devices even if the contents remain
the same.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>restore_plans_devices</strong>: <em>boolean</em> (optional)</dt><dd><p>reload the lists of existing plans and devices from disk if <em>True</em>, otherwise
use current lists stored in memory. Default: <em>False</em>.</p>
</dd>
<dt><strong>restore_permissions</strong>: <em>boolean</em> (optional)</dt><dd><p>reload user group permissions from disk if <em>True</em>, otherwise use current permissions.
Default: <em>True</em>.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="permissions-get">
<span id="method-permissions-get"></span><h4><strong>‘permissions_get’</strong><a class="headerlink" href="#permissions-get" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘permissions_get’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Download the dictionary of user group permissions currently used by RE Manager.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>user_group_permissions</strong>: <em>dict</em></dt><dd><p>dictionary containing user group permissions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="permissions-set">
<span id="method-permissions-set"></span><h4><strong>‘permissions_set’</strong><a class="headerlink" href="#permissions-set" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘permissions_set’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Uploads the dictionary of user group permissions. If the uploaded dictionary contains
a valid set of permissions different from currently used one, the new permissions
are set as current and the updated lists of allowed plans and devices are generated.
The method does nothing if the uploaded permissions are identical to currently used
permissions. The API request fails if the uploaded dictionary does not pass validation.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>user_group_permissions</strong>: <em>dict</em></dt><dd><p>dictionary, which contains user group permissions.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="history-get">
<span id="method-history-get"></span><h4><strong>‘history_get’</strong><a class="headerlink" href="#history-get" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘history_get’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns the list of items in the plan history.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl>
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>items</strong>: <em>list</em></dt><dd><p>list of items in the plan history, each item is represented by a dictionary of
item parameters. Currently the plan history may contain only plans.</p>
<p>The dictionary contains a copy of the original item parameters and dictionary with results of
execution (<strong>‘result’</strong> key), which contains the following keys:</p>
<ul class="simple">
<li><p><strong>exit_status</strong> - exit status of the plan. The values are <strong>‘completed’</strong> (the plan execution
is successfully completed), <strong>‘failed’</strong> (the plan execution failed; a plan can fail due to
multiple reasons, including internal error of RE Manager; see the error message to determine
the reason of failure), <strong>‘stopped’</strong> (the plan was paused, then stopped; the plan is considered
successfully executed), <strong>‘abort’</strong> and <strong>‘halt’</strong> (the plan was paused, then aborted or halted;
the plan is considered failed), <strong>‘unknown’</strong> (the exit status information is lost, e.g. due
to restart of RE Manager process, but plan information still needs to be placed in the history;
this is very unlikely to happen in practice);</p></li>
<li><p><strong>run_uids</strong> - list of UIDs of runs executed by the plan;</p></li>
<li><p><strong>time_start</strong> and <strong>time_stop</strong> - time of start and completion of the plan (not runs),
floating point number returned by <em>time.time()</em>.</p></li>
<li><p><strong>msg</strong> - error message if the plan failed, empty string otherwise.</p></li>
<li><p><strong>traceback</strong> - full traceback if the plan failed, empty string otherwise.</p></li>
</ul>
</dd>
<dt><strong>plan_history_uid</strong>: <em>str</em></dt><dd><p>current plan history UID.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="history-clear">
<span id="method-history-clear"></span><h4><strong>‘history_clear’</strong><a class="headerlink" href="#history-clear" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘history_clear’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Clear the contents of the plan history.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="environment-open">
<span id="method-environment-open"></span><h4><strong>‘environment_open’</strong><a class="headerlink" href="#environment-open" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘environment_open’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Initiate the creation of a new RE Worker environment. The request will
succeed only if RE Manager is in ‘idle’ state and the environment does not exist.
RE Worker environment must be created before plans could be executed. To restart
the environment, close the existing environment first by sending ‘environment_close’
request. To destroy ‘frozen’ environment, use ‘environment_destroy’ method.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request only initiates the sequence of creating a new environment. It may take
a long time to start the environment. Monitor ‘manager_state’
and ‘worker_environment_exists’ status fields (‘status’ method) to detect when
the operation is completed: ‘manager_state’ should have the value ‘opening_environment’
while operation is in progress and change to ‘idle’ when the operation completes and
‘worker_environment_exists’ is set to True if environment was created successfully.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="environment-close">
<span id="method-environment-close"></span><h4><strong>‘environment_close’</strong><a class="headerlink" href="#environment-close" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘environment_close’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Initiate the operation of closing the existing RE Worker environment. Fails if there
is no existing environment or if RE Manager is not in ‘idle’ state. Use
‘environment_destroy’ method to close a non-responsive RE Worker environment.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request initiates the sequence of closing the environment.
Monitor ‘manager_state’ and ‘worker_environment_exists’ status fields
(see ‘status’ method) to detection when the operation coompletes:
‘manager_state’ is expected to have the value ‘closing_environment’
while operation is in progress and switch to ‘idle’ when the operation completes
and ‘worker_environment_exists’ is set False if environment was closed successfully.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="environment-destroy">
<span id="method-environment-destroy"></span><h4><strong>‘environment_destroy’</strong><a class="headerlink" href="#environment-destroy" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘environment_destroy’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Initiate the operation of destroying of the existing (unresponsive) RE Worker
environment. The operation fails if there is no existing environment.
The request is accepted by the server if status fields <strong>worker_environment_exists</strong> is
<em>True</em> or <strong>manager_state</strong> is <em>‘creating_environment’</em>, otherwise the request is
rejected.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request initiates the sequence of destroying the environment.
Monitor ‘manager_state’ and ‘worker_environment_exists’ status fields
(see ‘status’ method): ‘manager_state’ is expected to have the value
‘destroying_environment’ while operation is in progress and switch to ‘idle’ when
the operation completes and ‘worker_environment_exists’ is set False if environment
was destroyed successfully.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-mode-set">
<span id="method-queue-mode-set"></span><h4><strong>‘queue_mode_set’</strong><a class="headerlink" href="#queue-mode-set" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_mode_set’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Sets parameters that define the mode of plan queue execution. The key/value pairs of the <em>‘mode’</em>
dictionary represent names and values of the parameters that need to be changed.
If <em>mode={}</em> then the mode will not be changed. To reset the mode parameters to the
built-in default values, set <em>mode=”default”</em>. The request fails if the <em>‘mode’</em> parameter
is not a dictionary or the <em>‘default’</em> string, the dictionary contains unsupported keys
(mode parameters) or key values are of unsupported type. Supported mode parameters
(dictionary keys): <em>‘loop’</em> (<em>True/False</em>) - enables/disables loop mode.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>mode</strong>: <em>dict</em> or <em>str</em></dt><dd><p>the dictionary of queue mode parameters or <em>‘default’</em> string. Supported keys of
the dictionary: <em>‘loop’</em> (<em>boolean</em>).</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-get">
<span id="method-queue-get"></span><h4><strong>‘queue_get’</strong><a class="headerlink" href="#queue-get" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_get’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns the items in the plan queue. The returned list of items may contain plans or
instructions. Each item is represented as a dictionary. Plans and instructions can be
distinguished by checking the value with the key ‘item_type’: ‘plan’ indicates that
the item is a plan, while ‘instruction’ indicates that it is an instruction.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>items</strong>: <em>list</em></dt><dd><p>list of queue items</p>
</dd>
<dt><strong>running_item</strong>: <em>dict</em></dt><dd><p>parameters of the item representing currently running plan, empty dictionary ({}) is
returned if no plan is currently running.</p>
</dd>
<dt><strong>plan_queue_uid</strong>: <em>str</em></dt><dd><p>current plan queue UID.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-add">
<span id="method-queue-item-add"></span><h4><strong>‘queue_item_add’</strong><a class="headerlink" href="#queue-item-add" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_add’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Add item to the queue. The item may be a plan or an instruction. By default the
item is added to the back of the queue. Alternatively the item can be placed at
the desired position in the queue or before or after one of the existing items.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of plan or instruction parameters. Plans are distinguished from
instructions based the value of the required parameter ‘item_type’. Currently
supported item types are ‘plan’ and ‘instruction’.</p>
</dd>
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>the name of the user (e.g. ‘Default User’). The name is included in the item metadata
and may be used to identify the user who added the item to the queue. It is not
passed to the Run Engine or included in run metadata.</p>
</dd>
<dt><strong>pos</strong>: <em>int</em>, <em>‘front’</em> or <em>‘back’</em> (optional)</dt><dd><p>position of the item in the queue. RE Manager will attempt to insert the item
at the specified position. The position may be positive or negative (counted
from the back of the queue) integer. If ‘pos’ value is a string ‘front’ or ‘back’,
then the item is inserted at the front or the back of the queue.</p>
</dd>
<dt><strong>before_uid</strong>, <strong>after_uid</strong>: <em>str</em> (optional)</dt><dd><p>insert the item before or after the item with the given item UID.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
<p><em>Parameters ‘pos’, ‘before_uid’ and ‘after_uid’ are mutually exclusive.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the number of items in the plan queue after the plan was added if
the operation was successful, <em>None</em> otherwise</p>
</dd>
<dt><strong>item</strong>: <em>dict</em> or <em>None</em> (optional)</dt><dd><p>the inserted item. The item contains the assigned item UID. In case of error
the item may be returned without modification (with assigned UID). <em>None</em> will be
returned if request does not contain item parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-add-batch">
<span id="method-queue-item-add-batch"></span><h4><strong>‘queue_item_add_batch’</strong><a class="headerlink" href="#queue-item-add-batch" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_add_batch’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Add a batch of items to the queue. The behavior of the function is identical to
<strong>queue_item_add</strong>, except that it adds the batch of items instead of a single item.
The batch may consist of any number of supported items (see <strong>queue_item_add</strong> method).
Each item in the queue must successfully pass validation before any items are added
to the queue. If an item fails validation, the whole batch is rejected. In case the
batch is rejected, the function returns the detailed report for each item: <em>success</em>
status indicating if the item passed validation and error message in case
validation failed.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>items</strong>: <em>list</em></dt><dd><p>the list containing a batch of items. Each element is a dictionary containing
valid set of item parameters (see instructions for <em>queue_item_add</em> API).
An empty item list will also be accepted.</p>
</dd>
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>the name of the user (e.g. ‘Default User’). The name is included in the item metadata
and may be used to identify the user who added the item to the queue. It is not
passed to the Run Engine or included in run metadata.</p>
</dd>
<dt><strong>pos</strong>: <em>int</em>, <em>‘front’</em> or <em>‘back’</em> (optional)</dt><dd><p>position of the first item of the batch in the queue. RE Manager will attempt to
insert the batch of items so that the first item in the batch is at the specified
position. The position may be positive or negative (counted from the back of the queue)
integer. If ‘pos’ value is a string ‘front’ or ‘back’, then the items are inserted at
the front or the back of the queue.</p>
</dd>
<dt><strong>before_uid</strong>, <strong>after_uid</strong>: <em>str</em> (optional)</dt><dd><p>insert the batch of items before or after the item with the given item UID.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
<p><em>Parameters ‘pos’, ‘before_uid’ and ‘after_uid’ are mutually exclusive.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl>
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully. The request fails if any item
fails validation. The queue is not expected to be modified if the request fails.
If the parameter is <em>True</em>, then validation of all items succeeded: there is no
need to verify <em>success</em> status for each item returned in <em>item_list</em> parameter.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the number of items in the plan queue after processing the request. The correct
queue size may be returned even if the operation fails. In rare failing cases
the parameter may return <em>None</em>.</p>
</dd>
<dt><strong>items</strong>: <em>list</em></dt><dd><p>the list of processed items. Each item contains inserted item (in case of success),
passed item or None (in case of error). See notes for return <em>item</em> parameter
for <em>queue_add_item</em> API.</p>
</dd>
<dt><strong>results</strong>: <em>list</em></dt><dd><blockquote>
<div><p>the list of reports for each processed item. The size of the list is equal to the
size of the list returned as <em>items</em> parameter. Each element of the list is
a dictionary containing the following keys:</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>success</strong> - boolean value indicating if the validation of the item was successful.</p></li>
<li><p><strong>msg</strong> - error message in case validation of the item failed.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-update">
<span id="method-queue-item-update"></span><h4><strong>‘queue_item_update’</strong><a class="headerlink" href="#queue-item-update" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_update’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Update the existing item in the queue. The method is intended for editing queue items,
but may be used for replacing the existing items with completely different ones.
The updated item may be a plan or an instruction. The item parameter ‘item_uid’ must
be set to a UID of an existing queue item that is expected to be replaced. The method
fails if the item UID is not found. By default, the UID of the updated item is not changed
and ‘user’ and ‘user_group’ parameters are set to the values provided in the request.
The ‘user_group’ is also used for validation of submitted item. If it is preferable
to replace the item UID with a new random UID (e.g. if the item is replaced with
completely different item), the method should be called with the optional parameter
‘replace=True’.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of plan or instruction parameters. Plans are distinguished from
instructions based the value of the required parameter ‘item_type’. Currently
supported item types are ‘plan’ and ‘instruction’.</p>
</dd>
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>the name of the user (e.g. ‘Default User’). The name is included in the item metadata
and may be used to identify the user who added the item to the queue. It is not
passed to the Run Engine or included in run metadata.</p>
</dd>
<dt><strong>replace</strong>: <em>boolean</em> (optional)</dt><dd><p>replace the updated item UID with the new random UID (True) or keep the original
UID (False). Default value is (False).</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the number of items in the plan queue after the plan was added if
the operation was successful, <em>None</em> otherwise</p>
</dd>
<dt><strong>item</strong>: <em>dict</em> or <em>None</em> (optional)</dt><dd><p>the inserted item. The item contains the assigned item UID. In case of error
the item may be returned without modification (with assigned UID). <em>None</em> will be
returned if request does not contain item parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-get">
<span id="method-queue-item-get"></span><h4><strong>‘queue_item_get’</strong><a class="headerlink" href="#queue-item-get" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_get’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Read item from the queue. By default the item from the back of the queue is returned.
Alternatively the item at the given position or the item with the given UID
may be requested.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>pos</strong>: <em>int</em>, <em>‘front’</em> or <em>‘back’</em> (optional)</dt><dd><p>position of the item in the queue. RE Manager will attempt to return the item
at the specified position. The position may be positive or negative (counted
from the back of the queue) integer. If ‘pos’ value is a string ‘front’ or ‘back’,
then the item at the front or the back of the queue is returned.</p>
</dd>
<dt><strong>uid</strong>: <em>str</em> (optional)</dt><dd><p>uid of the requested item.</p>
</dd>
</dl>
<p><em>Parameters ‘pos’ and ‘uid’ are mutually exclusive.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of item parameters, ({}) if operation failed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-remove">
<span id="method-queue-item-remove"></span><h4><strong>‘queue_item_remove’</strong><a class="headerlink" href="#queue-item-remove" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_remove’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Remove item from the queue. By default the last item in the queue is removed.
Alternatively the position or UID of the item can be specified.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>pos</strong>: <em>int</em>, <em>‘front’</em> or <em>‘back’</em> (optional)</dt><dd><p>position of the item in the queue. RE Manager will attempt to remove the item
at the specified position. The position may be positive or negative (counted
from the back of the queue) integer. If ‘pos’ value is a string ‘front’ or ‘back’,
then the item is removed from the front or the back of the queue.</p>
</dd>
<dt><strong>uid</strong>: <em>str</em> (optional)</dt><dd><p>uid of the requested item.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
<p><em>Parameters ‘pos’ and ‘uid’ are mutually exclusive.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of parameters of the removed item, ({}) if operation failed.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the number of items in the plan queue after the plan was added if
the operation was successful, <em>None</em> otherwise</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-remove-batch">
<span id="method-queue-item-remove-batch"></span><h4><strong>‘queue_item_remove_batch’</strong><a class="headerlink" href="#queue-item-remove-batch" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_remove_batch’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Remove a batch of items from the queue. The batch of items is defined as a list
of item UIDs and passed as the parameter <em>‘uids’</em>. The list of UIDs may be empty.
By default, the function does not validate the batch and deletes all batch items
found in the queue. Batch validation may be enabled by setting <em>‘ignore_missing=False’</em>.
In this case the method succeeds only if the batch does not contain repeated items
and all items are found in the queue. If validation fails then no items are removed
from the queue.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>uids</strong>: <em>list(str)</em> (<em>required</em>)</dt><dd><p>list of UIDs of the items in the batch. The list may not contain repeated UIDs.
All UIDs must be present in the queue. The list may be empty.</p>
</dd>
<dt><strong>ignore_missing</strong>: <em>boolean</em> (<em>optional, default: True</em>)</dt><dd><p>if the value is <em>‘False’</em>, then the method fails if the batch contains repeating
items or some of the batch items are not found in the queue. If <em>‘True’</em> (default),
then the method attempts to remove all items in the batch and ignores missing items.
The method returns the list of items that were removed from the queue.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>items</strong>: <em>list(dict)</em></dt><dd><p>the list of items that were removed during the operation. The items in the list are
arranged in the order in which they were removed. Returns empty list if the operation
fails.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the size of the queue or <em>None</em> if operation fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-move">
<span id="method-queue-item-move"></span><h4><strong>‘queue_item_move’</strong><a class="headerlink" href="#queue-item-move" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_move’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Move item to a different position in the queue.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>pos</strong>: <em>int</em>, <em>‘front’</em> or <em>‘back’</em></dt><dd><p>current position of the item in the queue. Integer number can be negative.</p>
</dd>
<dt><strong>uid</strong>: <em>str</em> (optional)</dt><dd><p>uid of the item to move.</p>
</dd>
<dt><strong>pos_dest</strong>: <em>int</em>, <em>‘front’</em>, <em>‘back’</em></dt><dd><p>new position of the item. Integer number can be negative.</p>
</dd>
<dt><strong>before_uid</strong>, <strong>after_uid</strong>: <em>str</em></dt><dd><p>UID of an existing item in the queue. The selected item will be moved
before or after this item.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
<p><em>Parameters ‘pos’ and ‘uid’ are mutually exclusive, but at least one of them must
be specified.</em></p>
<p><em>Parameters ‘pos_dest’, ‘before_uid’ and ‘after_uid’ are mutually exclusive,
but at least one of them must be specified.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of parameters of the moved item, ({}) if operation failed.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the size of the queue.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-move-batch">
<span id="method-queue-item-move-batch"></span><h4><strong>‘queue_item_move_batch’</strong><a class="headerlink" href="#queue-item-move-batch" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_move_batch’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Move a batch of item to a different position in the queue.
The method accepts a list of UIDs of the items included in the batch. The UIDs in the
list must be unique (not repeated) and items with listed UIDs must exist in the queue.
If the list is empty, then operation succeeds and the queue remains unchanged.
The destination must be specified using one of the mutually exclusive parameters
<em>‘pos_dest’</em>, <em>‘before_uid’</em> or <em>‘after_uid’</em>. The reference item with the UID of
passed with the parameters <em>‘before_uid’</em> or <em>‘after_uid’</em> must not be in the batch.
The parameter <em>‘reorder’</em> controls the order of the items in the moved batch and
indicates whether items in the batch should be reordered with respect to the order
of UIDs in the list <em>‘uids’</em>. The batch may include any set of non-repeated items
from the queue arranged in arbitrary order. By default (<em>reorder=False</em>) the batch
is inserted in the specified position as a contiguous sequence of items ordered
according to the UIDs in the list <em>‘uids’</em>. If <em>reorder=True</em>, then the inserted
items are ordered according to their original positions in the queue. It is assumed
that the method will be mostly used with the default ordering option and user will
be responsible for creating properly ordered lists of items. The other option is
implemented for the cases when the user may want to submit randomly ordered lists of
UIDs, but preserve the original order of the moved batch.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>uids</strong>: <em>list(str)</em> (<em>required</em>)</dt><dd><p>list of UIDs of the items in the batch. The list may not contain repeated UIDs.
All UIDs must be present in the queue. The list may be empty.</p>
</dd>
<dt><strong>pos_dest</strong>: <em>‘front’</em> or <em>‘back’</em></dt><dd><p>new position of the item. Only string values <em>“front”</em> and <em>“back”</em> are accepted.</p>
</dd>
<dt><strong>before_uid</strong>, <strong>after_uid</strong>: <em>str</em></dt><dd><p>UID of an existing item in the queue. The selected item will be moved
before or after this item. The item with the specified UID may not be included
in the batch.</p>
</dd>
<dt><strong>reorder</strong>: <em>boolean</em> (<em>optional, default: False</em>)</dt><dd><p>Arranged moved items in the order of UIDs in the <em>‘uids’</em> list
(<em>False</em>) or according to the original item positions in the queue (<em>True</em>).</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
<p><em>Parameters ‘pos_dest’, ‘before_uid’ and ‘after_uid’ are mutually exclusive,
but at least one of them must be specified.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>items</strong>: <em>list(dict)</em></dt><dd><p>the list of items that were moved during the operation. The items in the list are
arranged in the order in which they are inserted in the queue. Returns empty list
if the operation fails.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the size of the queue or <em>None</em> if operation fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-item-execute">
<span id="method-queue-item-execute"></span><h4><strong>‘queue_item_execute’</strong><a class="headerlink" href="#queue-item-execute" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_item_execute’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Immediately start execution of the submitted item. The item may be a plan or an
instruction. The request fails if item execution can not be started immediately
(RE Manager is not in <em>IDLE</em> state, RE Worker environment does not exist, etc.).
If the request succeeds, the item is executed once. The item is not added to
the queue if it can not be immediately started and it is not pushed back into
the queue in case its execution fails/stops. If the queue is in the <em>LOOP</em> mode,
the executed item is not added to the back of the queue after completion.
The API request does not alter the sequence of enqueued plans.</p>
<p>The API is primarily intended for implementing of interactive workflows, in which
users are controlling the experiment using client GUI application and user actions
(such as mouse click on a plot) are converted into the requests to execute plans
in RE Worker environment. Interactive workflows may be used for calibration of
the instrument, while the queue may be used to run sequences of scheduled experiments.</p>
<p>The item is not added to the queue or change the existing queue. The API modifies
<strong>plan_queue_uid</strong> status parameter, which is used for monitoring updates of
the queue and running items. If the item is a plan, the results of execution
are added to plan history as usual. The respective history item could be accessed
to check if the plan was executed successfully.</p>
<p>The API <strong>does not start execution of the queue</strong>. Once execution of the submitted
item is finished, RE Manager is switched to the IDLE state.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary of plan or instruction parameters. Plans are distinguished from
instructions based the value of the required parameter ‘item_type’. Currently
supported item types are ‘plan’ and ‘instruction’.</p>
</dd>
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>the name of the user (e.g. ‘Default User’). The name is included in the item metadata
and may be used to identify the user who added the item to the queue. It is not
passed to the Run Engine or included in run metadata.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>qsize</strong>: <em>int</em> or <em>None</em></dt><dd><p>the number of items in the plan queue, <em>None</em> if request fails otherwise.</p>
</dd>
<dt><strong>item</strong>: <em>dict</em> or <em>None</em> (optional)</dt><dd><p>the inserted item. The item contains the assigned item UID. In case of error
the item may be returned without modification (with assigned UID). <em>None</em> is
returned if request does not contain item parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-clear">
<span id="method-queue-clear"></span><h4><strong>‘queue_clear’</strong><a class="headerlink" href="#queue-clear" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_clear’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Remove all items from the plan queue. The currently running plan does not belong to
the queue and is not affected by this operation. If the plan fails or its execution
is stopped, it will be pushed to the beginning of the queue.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the queue</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-start">
<span id="method-queue-start"></span><h4><strong>‘queue_start’</strong><a class="headerlink" href="#queue-start" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_start’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Start execution of the queue. The operation succeeds only if RE Manager is in
‘idle’ state and RE Worker environment exists. This operation only initiates
the process of starting the execution of the queue.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request initiates the operation of starting the queue. Verify that the queue
is running by checking the status fields: ‘manager_state’ is expected to have
the value ‘executing_queue’ and ‘running_item_uid’ should return UID of
the running plan. It is possible that the queue execution is successfully started,
but immediately stopped (queue is empty, queue contains a very short plan,
the first plan in the queue fails to start, the first item in the queue is ‘queue_stop’
instruction etc.). RE Manager is expected to handle those cases in orderly way, but
the client should be capable of detecting and handling those events as well.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-stop">
<span id="method-queue-stop"></span><h4><strong>‘queue_stop’</strong><a class="headerlink" href="#queue-stop" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_stop’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Request RE Manager to stop execution of the queue after completion of the currently
running plan. The request succeeds only if the queue is currently running
(‘manager_state’ status field has value ‘executing_queue’). The ‘queue_stop_pending’
status field can be used at any time to verify if the request is pending.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="queue-stop-cancel">
<span id="method-queue-stop-cancel"></span><h4><strong>‘queue_stop_cancel’</strong><a class="headerlink" href="#queue-stop-cancel" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘queue_stop_cancel’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Cancel the pending request to stop execution of the queue after the currently
running plan.</p>
<p><em>The request always succeeds</em>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="re-pause">
<span id="method-re-pause"></span><h4><strong>‘re_pause’</strong><a class="headerlink" href="#re-pause" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘re_pause’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Request Run Engine to pause currently running plan. The request will fail if RE Worker
environment does not exist or no plan is currently running. The request only initates
the sequence of pausing the plan.</p>
<p>If <em>deferred</em> pause is requested past the last checkpoint of the plan, the plan is run
to completion and the queue is stopped. The stopped queue can not be resumed using
<strong>re_resume</strong> method, instead <strong>queue_start</strong> method should be used to restart the queue.
Check <strong>manager_state</strong> status flag to determine if the queue is stopped (<em>‘idle’</em> state)
or Run Engine is paused (<em>‘paused’</em> state).</p>
<p>The <strong>pause_pending</strong> status flag is set if pause request is successfully passed to Run
Engine. It may take significant time for deferred pause to be processed. The flag
is cleared once the pending pause request is processed (the plan is paused or plan
is completed and the queue is stopped).</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>option</strong>: <em>‘immediate’</em> or <em>‘deferred’</em> (optional)</dt><dd><p>pause the plan immediately (roll back to the previous checkpoint) or continue
to the next checkpoint. Default: <em>‘deferred’</em>.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request only initiates the operation of pausing the plan. Wait until the plan is
paused by polling ‘manager_state’ status field (expected value is ‘paused’).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="re-resume-re-stop-re-abort-re-halt">
<span id="method-re-resume-stop-abort-halt"></span><h4><strong>‘re_resume’, ‘re_stop’, ‘re_abort’, ‘re_halt’</strong><a class="headerlink" href="#re-resume-re-stop-re-abort-re-halt" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘re_resume’</strong>, <strong>‘re_stop’</strong>, <strong>‘re_abort’</strong>, <strong>‘re_halt’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Request Run Engine to resume, stop, abort or halt a paused plan. Fails if RE Worker
environment does not exist or ‘manager_state’ status field value is not ‘paused’.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request only initiates the operation. Wait until the plan is paused by monitoring
‘manager_state’ status field (expected value is ‘executing_queue’ if execution is
resumed or ‘idle’ if execution was stopped).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="re-runs">
<span id="method-re-runs"></span><h4><strong>‘re_runs’</strong><a class="headerlink" href="#re-runs" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘re_runs’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Request the list of active runs generated by the currently executed plans.
The full list of active runs includes the runs that are currently open (‘open’ runs) and
the runs that were already closed (‘closed’ runs). Simple single-run plans will have
at most one run in the list. Monitor ‘run_list_uid’ RE Manager status field and
retrieve the updated list once UID is changed. The UID of the retrieved list is
included in the returned parameters</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>option</strong>: <em>‘active’</em>, <em>‘open’</em> or <em>‘closed’</em> (optional)</dt><dd><p>select between full list of ‘active’ (default) runs, the list of ‘open’ or ‘closed’
runs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>run_list</strong>: <em>list(dict)</em></dt><dd><p>the requested list of runs, list items are dictionaries with keys ‘uid’ (str),
‘is_open’ (boolean) and ‘exit_status’ (str or None). See Bluesky documentation
for ‘exit_status’ values.</p>
</dd>
<dt><strong>run_list_uid</strong>: str</dt><dd><p>UID of the returned run list, identical to the RE Manager status field with
the same name.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="script-upload">
<span id="method-script-upload"></span><h4><strong>‘script_upload’</strong><a class="headerlink" href="#script-upload" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘script_upload’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Upload and execute script in RE Worker namespace. The script may add, change or replace
objects defined in the namespace, including plans and devices. Dynamic modification
of the worker namespace may be used to implement more flexible workflows. The API call
updates the lists of existing and allowed plans and devices if necessary. Changes in
the lists will be indicated by changed list UIDs. Use <em>‘task_result’</em> API to check
if the script was loaded correctly. Note, that if the task fails, the script is
still executed to the point where the exception is raised and the respective changes
to the environment are applied.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>script</strong>: <em>str</em></dt><dd><p>The string that contains the Python script. The rules for the script are the same
as for Bluesky startup scripts. The script can use objects already existing in
the RE Worker namespace.</p>
</dd>
<dt><strong>update_lists</strong>: <em>boolean</em> (optional, default <em>True</em>)</dt><dd><p>Update lists of existing and available plans and devices after execution of the script.
It is required to update the lists if the script adds or modifies plans and/or devices
in RE Worker namespace, but it is more efficient to disable the update for other scripts,
e.g. the scripts that print or modify variables in the namespace during iteractive debug
session.</p>
</dd>
<dt><strong>update_re</strong>: <em>boolean</em> (optional, default <em>False</em>)</dt><dd><p>The uploaded scripts may replace Run Engine (<em>‘RE’</em>) and Data Broker (<em>‘db’</em>)
instances in the namespace. In most cases this operation should not be allowed,
therefore it is disabled by default (<em>update_re</em> is <em>False</em>), i.e. if the script
creates new <em>RE</em> and <em>db</em> objects, those objects are discarded. Set this parameter
<em>True</em> to allow the server to replace <em>RE</em> and <em>db</em> objects. This parameter has
no effect if the script is not creating new instances of <em>RE</em> and/or <em>db</em>.</p>
</dd>
<dt><strong>run_in_background</strong>: <em>boolean</em> (optional, default <em>False</em>)</dt><dd><p>Set this parameter <em>True</em> to upload and execute the script in the background
(while a plan or another foreground task is running). Generally, it is not
recommended to update RE Worker namespace in the background. Background tasks
are executed in separate threads and only thread-safe scripts should be uploaded
in the background. <strong>Developers of data acquisition workflows and/or user
specific code are responsible for thread safety.</strong></p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>task_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>Task UID can be used to check status of the task and download results once the task
is completed (see <em>task_result</em> API).</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The method initiates the operation. Monitor <em>task_results_uid</em> status field and call
<em>task_result</em> API to check for success.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="function-execute">
<span id="method-function-execute"></span><h4><strong>‘function_execute’</strong><a class="headerlink" href="#function-execute" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘function_execute’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Start execution of a function in RE Worker namespace. The function must be defined in the
namespace (in startup code or a script uploaded using <em>script_upload</em> method. The function
may be executed as a foreground task (only if RE Manager and RE Worker environment are idle)
or as a background task. Background tasks are executed in separate threads and may
consume processing or memory resources and interfere with running plans or other tasks.
RE Manager does not guarantee thread safety of the user code running in the background.
Developers of startup code are fully responsible for preventing threading issues.</p>
<p>The method allows to pass parameters (<em>args</em> and <em>kwargs</em>) to the function. Once the task
is completed, the results of the function execution, including the return value, can be
loaded using <em>task_result</em> method. If the task fails, the return value is <em>None</em> and
the error message and traceback are included in the result. The data types of
parameters and return values must be JSON serializable. The task fails if the return
value can not be serialized.</p>
<p>The method only <strong>initiates</strong> execution of the function. If the request is successful
(<em>success=True</em>), the server starts the task, which attempts to execute the function
with given name and parameters. The function may still fail start (e.g. if the user is
permitted to execute function with the given name, but the function is not defined
in the namespace). Use <em>‘task_result’</em> method with the returned <em>task_uid</em> to
check the status of the tasks and load the result upon completion.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>item</strong>: <em>dict</em></dt><dd><p>the dictionary that contains function name and parameters. The structure of
dictionary is identical to <em>item</em> representing a plan or an instruction,
except that <em>item_type</em> is <em>‘function’</em>.</p>
</dd>
<dt><strong>user_group</strong>: <em>str</em></dt><dd><p>the name of the user group (e.g. ‘primary’).</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>the name of the user (e.g. ‘Default User’). The name is included in the item metadata
and may be used to identify the user who submitted the item.</p>
</dd>
<dt><strong>run_in_background</strong>: <em>boolean</em> (optional, default <em>False</em>)</dt><dd><p>Set this parameter <em>True</em> to start a background task. Background tasks can be
started and executed while a plan or another foreground task is running.
If workflow requires executing background tasks, user code should be analyzed
for thread safety to ensure there are no potential threading issues.
<strong>Developers of data acquisition workflows and/or user specific code are
responsible for thread safety.</strong></p>
</dd>
<dt><strong>lock_key</strong>: <em>str</em> (optional)</dt><dd><p>Lock key. The API fails if <strong>the environment</strong> is locked and no valid key is submitted
with the request. See documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>item</strong>: <em>dict</em> or <em>None</em> (optional)</dt><dd><p>the item with information on the function. The item contains the assigned item UID.
In case of error the item may be returned without modification. <em>None</em> will be
returned if request does not contain item parameters. In current implementation
the assigned <em>item_uid</em> is equal to <em>task_uid</em>, but it may change in the future.</p>
</dd>
<dt><strong>task_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>task UID can be used to check status of the task and download results once the task
is completed (see <em>task_result</em> API). <em>None</em> is returned if the request fails.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The method initiates the operation. Monitor <em>task_results_uid</em> status field and call
<em>task_result</em> API to check for success.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="task-status">
<span id="method-task-status"></span><h4><strong>‘task_status’</strong><a class="headerlink" href="#task-status" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘task_status’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Returns the status of one or more tasks executed by the worker process. The request
must contain one or more valid task UIDs, returned by one of APIs that starts tasks.
A single UID may be passed as a string, multiple UIDs must be passed as as a list of
strings. If a UID is passed as a string, then the returned status is also a string,
if a list of one or more UIDs is passed, then the status is a dictionary that maps
task UIDs and their status. The completed tasks are stored at the server at least
for the period determined by retention time (currently 120 seconds after completion
of the task). The expired results could be automatically deleted at any time and
the method will return the task status as <em>‘not_found’</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>task_uid</strong>: <em>str</em> or <em>list(str)</em></dt><dd><p>Task UID or a list of task UIDs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>task_uid</strong>: <em>str</em>, <em>list(str)</em> or <em>None</em></dt><dd><p>task UID or a list of task UIDs (expected to be the same as the input parameter).
May be <em>None</em> if the request fails.</p>
</dd>
<dt><strong>status</strong>: <em>str</em> or <em>dict</em></dt><dd><p>status of the task(s) or <em>None</em> if the request (not task) failed. If <strong>task_uid</strong>
is a string representing single UID, then <strong>status</strong> is a string, which is one of
of <em>‘running’</em>, <em>‘completed’</em> or <em>‘not_found’</em>. If <strong>task_uid</strong> is a list of strings,
then <em>‘status’</em> is a dictionary that maps task UIDs to status of the respective tasks.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="task-result">
<span id="method-task-result"></span><h4><strong>‘task_result’</strong><a class="headerlink" href="#task-result" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘task_result’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Get the status and results of task execution. The completed tasks are stored at
the server at least for the period determined by retention time (currently 120 seconds
after completion of the task). The expired results could be automatically deleted
at any time and the method will return the task status as <em>‘not_found’</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>task_uid</strong>: <em>str</em></dt><dd><p>Task UID.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>task_uid</strong>: <em>str</em> or <em>None</em></dt><dd><p>task UID (expected to be the same as the input parameter). May be <em>None</em> if
the request fails.</p>
</dd>
<dt><strong>status</strong>: <em>‘running’</em>, <em>‘completed’</em>, <em>‘not_found’</em> or <em>None</em></dt><dd><p>status of the task or <em>None</em> if the request (not task) failed.</p>
</dd>
<dt><strong>result</strong>: <em>dict</em> or <em>None</em></dt><dd><p>Dictionary containing the information on a running task, results of the completed
task or <em>None</em> if the request failed. The contents of the dictionary depends on the returned
<em>‘status’</em>:</p>
<ul class="simple">
<li><p><strong>‘running’</strong> - Keys: <em>‘task_uid’</em>, <em>‘start_time’</em> and <em>‘run_in_background’</em>.</p></li>
<li><p><strong>‘completed’</strong> - Keys: <em>‘task_uid’</em>, <em>‘success’</em> (<em>True</em>/<em>False</em>),
<em>‘msg’</em> (short error message, empty string if execution was successful),
<em>‘traceback’</em> (full traceback in case of error, empty string otherwise),
<em>‘return_value’</em> (value returned by the task, e.g. by the executed function,
<em>None</em> if the task failed), <em>‘time_start’</em> and <em>‘time_stop’</em>.</p></li>
<li><p><strong>‘not_found’</strong> - Empty dictionary.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="lock">
<span id="method-lock"></span><h4><strong>‘lock’</strong><a class="headerlink" href="#lock" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘lock’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Lock RE Manager with the provided lock key to prevent other clients from modifying
the environment, starting plans or tasks or editing the queue. The lock is not intended
for access control. The read-only API are not affected by the lock, therefore all monitoring
client applications are expected to remain functional after the lock is applied. The lock
does not influence internal operation of the manager, e.g. the running queue will continue
running and has to be explicitly stopped if needed.</p>
<p>Each lockable API has an optional parameter <strong>‘lock_key’</strong>. Passing a valid lock key
(used to lock RE Manager) with the API requests allows to control RE Manager while it is
locked. This supports the scenarios when a beamline scientists locks RE Manager with
a unique code before entering the hutch to change samples or make adjustments and then
safely runs a series of calibration or testing plans without interference from automated
agents or remote users. A remote operators may still control locked RE Manager if
the beamline scientists provides them with the lock key.</p>
<p>The API parameters allow to choose between locking the <strong>environment</strong>, the <strong>queue</strong> or both.
Locking the <strong>environment</strong> affects the following API:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-environment-open"><span class="std std-ref">‘environment_open’</span></a></p></li>
<li><p><a class="reference internal" href="#method-environment-close"><span class="std std-ref">‘environment_close’</span></a></p></li>
<li><p><a class="reference internal" href="#method-environment-destroy"><span class="std std-ref">‘environment_destroy’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-start"><span class="std std-ref">‘queue_start’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-stop"><span class="std std-ref">‘queue_stop’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-stop-cancel"><span class="std std-ref">‘queue_stop_cancel’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-execute"><span class="std std-ref">‘queue_item_execute’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-pause"><span class="std std-ref">‘re_pause’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_resume’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_stop’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_abort’</span></a></p></li>
<li><p><a class="reference internal" href="#method-re-resume-stop-abort-halt"><span class="std std-ref">‘re_halt’</span></a></p></li>
<li><p><a class="reference internal" href="#method-script-upload"><span class="std std-ref">‘script_upload’</span></a></p></li>
<li><p><a class="reference internal" href="#method-function-execute"><span class="std std-ref">‘function_execute’</span></a></p></li>
</ul>
<p>Locking the <strong>queue</strong> affects the following API:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#method-queue-mode-set"><span class="std std-ref">‘queue_mode_set’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-add"><span class="std std-ref">‘queue_item_add’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-add-batch"><span class="std std-ref">‘queue_item_add_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-update"><span class="std std-ref">‘queue_item_update’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-remove"><span class="std std-ref">‘queue_item_remove’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-remove-batch"><span class="std std-ref">‘queue_item_remove_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-move"><span class="std std-ref">‘queue_item_move’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-item-move-batch"><span class="std std-ref">‘queue_item_move_batch’</span></a></p></li>
<li><p><a class="reference internal" href="#method-queue-clear"><span class="std std-ref">‘queue_clear’</span></a></p></li>
<li><p><a class="reference internal" href="#method-history-clear"><span class="std std-ref">‘history_clear’</span></a></p></li>
<li><p><a class="reference internal" href="#method-permissions-reload"><span class="std std-ref">‘permissions_reload’</span></a></p></li>
<li><p><a class="reference internal" href="#method-permissions-set"><span class="std std-ref">‘permissions_set’</span></a></p></li>
</ul>
<p>The additional parameters include the name of the user (<strong>user</strong>, required) who locked
RE Manager and the message to other users (<strong>note</strong>, optional) which may explain
the reason why the manager is locked. The user name and the note is returned by
<strong>lock_info</strong> API and included in the <em>‘Invalid lock key’</em> error messages.</p>
<p>An emergency lock key may be optionally set using
<code class="docutils literal notranslate"><span class="pre">QSERVER_EMERGENCY_LOCK_KEY_FOR_SERVER</span></code> environment variable. The emergency key
could be used to unlock RE Manager if the lock key is lost. The emergency lock key is
accepted only by the <strong>unlock</strong> API.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Restarting RE Manager does not change the lock status. The manager has to be unlocked
using the valid lock key or the emergency lock key.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em></dt><dd><p>The lock key is an arbitrary non-empty string. Users/clients are expected to keep
the key used to lock RE Manager and use it to unlock the manager or make API requests.
If the lock key is lost by accident, then RE Manager may be unlocked using the
emergency lock key.</p>
</dd>
<dt><strong>environment</strong>: <em>boolean</em> (optional, default: <em>False</em>)</dt><dd><p>Enable lock for the API that control RE Worker environment. The request fails
if both <strong>environment</strong> and <strong>queue</strong> are missing or <em>False</em>.</p>
</dd>
<dt><strong>queue</strong>: <em>boolean</em> (optinal, default: <em>False</em>)</dt><dd><p>Enable lock for the API that control the queue. The request fails
if both <strong>environment</strong> and <strong>queue</strong> are missing or <em>False</em>.</p>
</dd>
<dt><strong>user</strong>: <em>str</em></dt><dd><p>Name of the user who submits the request. The user name is returned as part of
<em>lock_info</em> and included in error messages.</p>
</dd>
<dt><strong>note</strong>: <em>str</em> or <em>None</em> (optional, default: <em>None</em>)</dt><dd><p>A text message to other users that explains the reason why RE Manager is locked.
The note is returned as part of <em>lock_info</em> and included in error messages.
If the value is <em>None</em>, then no message submitted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>lock_info</strong>: <em>dict</em></dt><dd><p>Dictionary containing the information on the status of the lock. The dictionary
is also returned by <strong>lock_info</strong> API and includes the following fields:</p>
<ul class="simple">
<li><p><strong>‘environment’</strong> (<em>boolean</em>) - indicates if the RE Worker environment is locked.</p></li>
<li><p><strong>‘queue’</strong> (<em>boolean</em>) - indicates if the queue is locked.</p></li>
<li><p><strong>‘user’</strong> (<em>str</em> or <em>None</em>) - the name of the user who locked RE Manager,
<em>None</em> if the lock is not set.</p></li>
<li><p><strong>‘note’</strong> (<em>str</em> or <em>None</em>) - the text note left by the user who locked RE Manager,
<em>None</em> if the lock is not set.</p></li>
<li><p><strong>‘time’</strong> (<em>float</em> or <em>None</em>) - timestamp (time when RE Manager was locked),
<em>None</em> if the lock is not set.</p></li>
<li><p><strong>‘time_str’</strong> (<em>str</em>) - human-readable representation of the timestamp,
empty string if the lock is not set.</p></li>
<li><p><strong>‘emergency_lock_key_is_set’</strong> (<em>boolean</em>) - indicates if the optional emergency
lock key is set.</p></li>
</ul>
</dd>
<dt><strong>lock_info_uid</strong>: <em>str</em></dt><dd><p>UID of <em>lock_info</em>. The UID is also returned in RE Manager status and could be
monitored to detect updates of <em>lock_info</em>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="lock-info">
<span id="method-lock-info"></span><h4><strong>‘lock_info’</strong><a class="headerlink" href="#lock-info" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘lock_info’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Load the lock status of RE Manager and optionally validate the lock key. Monitor
<em>lock_info_uid</em> field of RE Manager status (see documentation for the <a class="reference internal" href="#method-status"><span class="std std-ref">‘status’</span></a>
API) to detect changes in lock status and download the lock status only when the UID changes.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em> or <em>None</em> (optional, default: <em>None</em>)</dt><dd><p>The parameter is used to validate the lock key (not the emergency lock key, see
the documentation for <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API). If the lock key is a string that matches
the key used to lock RE Manager, then the request succeeds. If no lock key is passed
with the request, the lock key is <em>None</em> or RE Manager is not locked, then no validation
is performed and the request always succeeds. The request fails if RE Manager is
locked and <em>lock_key</em> is not valid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully. The request succeeds if RE Manager
is unlocked or the <em>lock_key</em> parameter is not specified or <em>None</em>. If <em>lock_key</em> is
a string, then the request succeeds if the key is valid and fails otherwise.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>lock_info</strong>: <em>dict</em></dt><dd><p>Dictionary containing the information on the status of the lock. See the documentation
on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for the detailed description.</p>
</dd>
<dt><strong>lock_info_uid</strong>: <em>str</em></dt><dd><p>UID of <em>lock_info</em>. The UID is also returned in RE Manager status and could be
monitored to detect updates of <em>lock_info</em>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="unlock">
<span id="method-unlock"></span><h4><strong>‘unlock’</strong><a class="headerlink" href="#unlock" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘unlock’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Unlock RE Manager with the lock key used to lock the manager or the emergency lock
key. See the documentation for <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for more details.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>lock_key</strong>: <em>str</em></dt><dd><p>The lock key must match the key used to lock RE Manager (with <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API)
or the emergency lock key.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
<dt><strong>lock_info</strong>: <em>dict</em></dt><dd><p>Dictionary containing the updated information on the lock status after the request
is processed. See the documentation on <a class="reference internal" href="#method-lock"><span class="std std-ref">‘lock’</span></a> API for the detailed
description.</p>
</dd>
<dt><strong>lock_info_uid</strong>: <em>str</em></dt><dd><p>UID of <em>lock_info</em>. The UID is also returned in RE Manager status and could be
monitored to detect updates of <em>lock_info</em>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="manager-stop">
<span id="method-manager-stop"></span><h4><strong>‘manager_stop’</strong><a class="headerlink" href="#manager-stop" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘manager_stop’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Exit RE Manager application. Clients will probably not need to initiate exit remotely,
but ability to do so is extremely useful for automated testing.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><dl class="simple">
<dt><strong>option</strong>: <em>‘safe_on’</em> or <em>‘safe_off’</em> (optional)</dt><dd><p>if the option of ‘safe_on’ is selected (default), then the request fails
unless ‘manager_state’ status field is ‘idle’ (no plans are running).
If the option is ‘safe_off’ then RE Worker environment is destroyed
(worker process is terminated and all data that was not saved is discarded).</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><dl class="simple">
<dt><strong>success</strong>: <em>boolean</em></dt><dd><p>indicates if the request was processed successfully.</p>
</dd>
<dt><strong>msg</strong>: <em>str</em></dt><dd><p>error message in case of failure, empty string (‘’) otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>The request only initiates the operation of exiting RE Manager. If the request succeeds
it may be expected that RE Manager application will eventually be exited and stops it
stops responding to requests.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="manager-kill">
<span id="method-manager-kill"></span><h4><strong>‘manager_kill’</strong><a class="headerlink" href="#manager-kill" title="Permalink to this heading">¶</a></h4>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Method</p></td>
<td><p><strong>‘manager_kill’</strong></p></td>
</tr>
<tr class="row-even"><td><p>Description</p></td>
<td><p>Freezes RE Manager process by stopping the asyncio event loop. By design, the manager
process is expected to restart after 5 seconds of inactivity. The restart of the manager
process should not affect the state of the queue or running plans. This function is
implemented for testing purposes only. There is no practical reason for a client
application to send this request.</p></td>
</tr>
<tr class="row-odd"><td><p>Parameters</p></td>
<td><p>—</p></td>
</tr>
<tr class="row-even"><td><p>Returns</p></td>
<td><p>RE Manager will not respond to the request.</p></td>
</tr>
<tr class="row-odd"><td><p>Execution</p></td>
<td><p>Immediate: no follow-up requests are required.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="generated/bluesky_queueserver.format_text_descriptions.html" class="btn btn-neutral float-left" title="bluesky_queueserver.format_text_descriptions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="generated/bluesky_queueserver.ZMQCommSendAsync.html" class="btn btn-neutral float-right" title="bluesky_queueserver.ZMQCommSendAsync" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, Brookhaven National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>